
#include <iostream>
#include <random>

#include <Eigen/Dense>
#include <finite-diff/finitediff.hpp>
#include "./3rd-party/autodiff/reverse/var.hpp"
#include "./3rd-party/autodiff/reverse/var/eigen.hpp"


namespace autogen {

	// This function was generated by the Symbolic Math Toolbox version 8.3.
	// 01-Nov-2019 16:54:23
	template<typename T>
	void edge_edge_cross_squarednorm_gradient(
		T v01,
		T v02,
		T v03,
		T v11,
		T v12,
		T v13,
		T v21,
		T v22,
		T v23,
		T v31,
		T v32,
		T v33,
		T g[12])
	{
		T t8, t9, t10, t11, t12, t13, t23, t24, t25, t26, t27, t28, t29,
			t30, t31, t32, t33;

		t8 = -v11 + v01;
		t9 = -v12 + v02;
		t10 = -v13 + v03;
		t11 = -v31 + v21;
		t12 = -v32 + v22;
		t13 = -v33 + v23;
		t23 = t8 * t12 + -(t9 * t11);
		t24 = t8 * t13 + -(t10 * t11);
		t25 = t9 * t13 + -(t10 * t12);
		t26 = t8 * t23 * 2.0;
		t27 = t9 * t23 * 2.0;
		t28 = t8 * t24 * 2.0;
		t29 = t10 * t24 * 2.0;
		t30 = t9 * t25 * 2.0;
		t31 = t10 * t25 * 2.0;
		t32 = t11 * t23 * 2.0;
		t33 = t12 * t23 * 2.0;
		t23 = t11 * t24 * 2.0;
		t10 = t13 * t24 * 2.0;
		t9 = t12 * t25 * 2.0;
		t8 = t13 * t25 * 2.0;
		g[0] = t33 + t10;
		g[1] = -t32 + t8;
		g[2] = -t23 - t9;
		g[3] = -t33 - t10;
		g[4] = t32 - t8;
		g[5] = t23 + t9;
		g[6] = -t27 - t29;
		g[7] = t26 - t31;
		g[8] = t28 + t30;
		g[9] = t27 + t29;
		g[10] = -t26 + t31;
		g[11] = -t28 - t30;
	}

	// This function was generated by the Symbolic Math Toolbox version 8.3.
	// 01-Nov-2019 16:54:23
	template<typename T>
	void edge_edge_cross_squarednorm_hessian(
		T v01,
		T v02,
		T v03,
		T v11,
		T v12,
		T v13,
		T v21,
		T v22,
		T v23,
		T v31,
		T v32,
		T v33,
		T H[144])
	{
		T t8, t9, t10, t11, t12, t13, t32, t33, t34, t35, t48, t36, t49,
			t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t50, t51,
			t52, t20, t23, t24, t25, t86, t87, t88, t74, t75, t76, t77, t78,
			t79, t89, t90, t91, t92, t93, t94, t95;

		t8 = -v11 + v01;
		t9 = -v12 + v02;
		t10 = -v13 + v03;
		t11 = -v31 + v21;
		t12 = -v32 + v22;
		t13 = -v33 + v23;
		t32 = t8 * t9 * 2.0;
		t33 = t8 * t10 * 2.0;
		t34 = t9 * t10 * 2.0;
		t35 = t8 * t11 * 2.0;
		t48 = t8 * t12;
		t36 = t48 * 2.0;
		t49 = t9 * t11;
		t37 = t49 * 2.0;
		t38 = t48 * 4.0;
		t48 = t8 * t13;
		t39 = t48 * 2.0;
		t40 = t49 * 4.0;
		t41 = t9 * t12 * 2.0;
		t49 = t10 * t11;
		t42 = t49 * 2.0;
		t43 = t48 * 4.0;
		t48 = t9 * t13;
		t44 = t48 * 2.0;
		t45 = t49 * 4.0;
		t49 = t10 * t12;
		t46 = t49 * 2.0;
		t47 = t48 * 4.0;
		t48 = t49 * 4.0;
		t49 = t10 * t13 * 2.0;
		t50 = t11 * t12 * 2.0;
		t51 = t11 * t13 * 2.0;
		t52 = t12 * t13 * 2.0;
		t20 = t8 * t8 * 2.0;
		t9 = t9 * t9 * 2.0;
		t8 = t10 * t10 * 2.0;
		t23 = t11 * t11 * 2.0;
		t24 = t12 * t12 * 2.0;
		t25 = t13 * t13 * 2.0;
		t86 = t35 + t41;
		t87 = t35 + t49;
		t88 = t41 + t49;
		t74 = t20 + t9;
		t75 = t20 + t8;
		t76 = t9 + t8;
		t77 = t23 + t24;
		t78 = t23 + t25;
		t79 = t24 + t25;
		t89 = t40 + -t36;
		t90 = t36 + -t40;
		t91 = t37 + -t38;
		t92 = t38 + -t37;
		t93 = t45 + -t39;
		t94 = t39 + -t45;
		t95 = t42 + -t43;
		t37 = t43 + -t42;
		t39 = t48 + -t44;
		t45 = t44 + -t48;
		t38 = t46 + -t47;
		t40 = t47 + -t46;
		t36 = -t35 + -t41;
		t13 = -t35 + -t49;
		t11 = -t41 + -t49;
		t12 = -t20 + -t9;
		t10 = -t20 + -t8;
		t8 = -t9 + -t8;
		t9 = -t23 + -t24;
		t49 = -t23 + -t25;
		t48 = -t24 + -t25;
		H[0] = t79;
		H[1] = -t50;
		H[2] = -t51;
		H[3] = t48;
		H[4] = t50;
		H[5] = t51;
		H[6] = t11;
		H[7] = t92;
		H[8] = t37;
		H[9] = t88;
		H[10] = t91;
		H[11] = t95;
		H[12] = -t50;
		H[13] = t78;
		H[14] = -t52;
		H[15] = t50;
		H[16] = t49;
		H[17] = t52;
		H[18] = t89;
		H[19] = t13;
		H[20] = t40;
		H[21] = t90;
		H[22] = t87;
		H[23] = t38;
		H[24] = -t51;
		H[25] = -t52;
		H[26] = t77;
		H[27] = t51;
		H[28] = t52;
		H[29] = t9;
		H[30] = t93;
		H[31] = t39;
		H[32] = t36;
		H[33] = t94;
		H[34] = t45;
		H[35] = t86;
		H[36] = t48;
		H[37] = t50;
		H[38] = t51;
		H[39] = t79;
		H[40] = -t50;
		H[41] = -t51;
		H[42] = t88;
		H[43] = t91;
		H[44] = t95;
		H[45] = t11;
		H[46] = t92;
		H[47] = t37;
		H[48] = t50;
		H[49] = t49;
		H[50] = t52;
		H[51] = -t50;
		H[52] = t78;
		H[53] = -t52;
		H[54] = t90;
		H[55] = t87;
		H[56] = t38;
		H[57] = t89;
		H[58] = t13;
		H[59] = t40;
		H[60] = t51;
		H[61] = t52;
		H[62] = t9;
		H[63] = -t51;
		H[64] = -t52;
		H[65] = t77;
		H[66] = t94;
		H[67] = t45;
		H[68] = t86;
		H[69] = t93;
		H[70] = t39;
		H[71] = t36;
		H[72] = t11;
		H[73] = t89;
		H[74] = t93;
		H[75] = t88;
		H[76] = t90;
		H[77] = t94;
		H[78] = t76;
		H[79] = -t32;
		H[80] = -t33;
		H[81] = t8;
		H[82] = t32;
		H[83] = t33;
		H[84] = t92;
		H[85] = t13;
		H[86] = t39;
		H[87] = t91;
		H[88] = t87;
		H[89] = t45;
		H[90] = -t32;
		H[91] = t75;
		H[92] = -t34;
		H[93] = t32;
		H[94] = t10;
		H[95] = t34;
		H[96] = t37;
		H[97] = t40;
		H[98] = t36;
		H[99] = t95;
		H[100] = t38;
		H[101] = t86;
		H[102] = -t33;
		H[103] = -t34;
		H[104] = t74;
		H[105] = t33;
		H[106] = t34;
		H[107] = t12;
		H[108] = t88;
		H[109] = t90;
		H[110] = t94;
		H[111] = t11;
		H[112] = t89;
		H[113] = t93;
		H[114] = t8;
		H[115] = t32;
		H[116] = t33;
		H[117] = t76;
		H[118] = -t32;
		H[119] = -t33;
		H[120] = t91;
		H[121] = t87;
		H[122] = t45;
		H[123] = t92;
		H[124] = t13;
		H[125] = t39;
		H[126] = t32;
		H[127] = t10;
		H[128] = t34;
		H[129] = -t32;
		H[130] = t75;
		H[131] = -t34;
		H[132] = t95;
		H[133] = t38;
		H[134] = t86;
		H[135] = t37;
		H[136] = t40;
		H[137] = t36;
		H[138] = t33;
		H[139] = t34;
		H[140] = t12;
		H[141] = -t33;
		H[142] = -t34;
		H[143] = t74;
	}

	template<typename T>
	void edge_edge_mollifier_threshold_gradient(
		T ea0x,
		T ea0y,
		T ea0z,
		T ea1x,
		T ea1y,
		T ea1z,
		T eb0x,
		T eb0y,
		T eb0z,
		T eb1x,
		T eb1y,
		T eb1z,
		T grad[12],
		T scale)
	{
		const auto t0 = ea0x - ea1x;
		const auto t1 = eb0x - eb1x;
		const auto t2 = eb0y - eb1y;
		const auto t3 = eb0z - eb1z;
		const auto t4 = 2 * scale;
		const auto t5 = t4 * ((t1 * t1) + (t2 * t2) + (t3 * t3));
		const auto t6 = t0 * t5;
		const auto t7 = ea0y - ea1y;
		const auto t8 = t5 * t7;
		const auto t9 = ea0z - ea1z;
		const auto t10 = t5 * t9;
		const auto t11 = t4 * ((t0 * t0) + (t7 * t7) + (t9 * t9));
		const auto t12 = t1 * t11;
		const auto t13 = t11 * t2;
		const auto t14 = t11 * t3;
		grad[0] = t6;
		grad[1] = t8;
		grad[2] = t10;
		grad[3] = -t6;
		grad[4] = -t8;
		grad[5] = -t10;
		grad[6] = t12;
		grad[7] = t13;
		grad[8] = t14;
		grad[9] = -t12;
		grad[10] = -t13;
		grad[11] = -t14;
	}



	// This function was generated by the Symbolic Math Toolbox version 8.3.
	// 10-Jun-2019 18:02:37
	template<typename T>
	void point_line_distance_gradient_3D(
		T v01,
		T v02,
		T v03,
		T v11,
		T v12,
		T v13,
		T v21,
		T v22,
		T v23,
		T g[9])
	{
		T t17, t18, t19, t20, t21, t22, t23, t24, t25, t42, t44, t45, t46,
			t43, t50, t51, t52;

		t17 = -v11 + v01;
		t18 = -v12 + v02;
		t19 = -v13 + v03;
		t20 = -v21 + v01;
		t21 = -v22 + v02;
		t22 = -v23 + v03;
		t23 = -v21 + v11;
		t24 = -v22 + v12;
		t25 = -v23 + v13;
		t42 = 1.0 / ((t23 * t23 + t24 * t24) + t25 * t25);
		t44 = t17 * t21 + -(t18 * t20);
		t45 = t17 * t22 + -(t19 * t20);
		t46 = t18 * t22 + -(t19 * t21);
		t43 = t42 * t42;
		t50 = (t44 * t44 + t45 * t45) + t46 * t46;
		t51 = (v11 * 2.0 + -(v21 * 2.0)) * t43 * t50;
		t52 = (v12 * 2.0 + -(v22 * 2.0)) * t43 * t50;
		t43 = (v13 * 2.0 + -(v23 * 2.0)) * t43 * t50;
		g[0] = t42 * (t24 * t44 * 2.0 + t25 * t45 * 2.0);
		g[1] = -t42 * (t23 * t44 * 2.0 - t25 * t46 * 2.0);
		g[2] = -t42 * (t23 * t45 * 2.0 + t24 * t46 * 2.0);
		g[3] = -t51 - t42 * (t21 * t44 * 2.0 + t22 * t45 * 2.0);
		g[4] = -t52 + t42 * (t20 * t44 * 2.0 - t22 * t46 * 2.0);
		g[5] = -t43 + t42 * (t20 * t45 * 2.0 + t21 * t46 * 2.0);
		g[6] = t51 + t42 * (t18 * t44 * 2.0 + t19 * t45 * 2.0);
		g[7] = t52 - t42 * (t17 * t44 * 2.0 - t19 * t46 * 2.0);
		g[8] = t43 - t42 * (t17 * t45 * 2.0 + t18 * t46 * 2.0);
	}




	// This function was generated by the Symbolic Math Toolbox version 8.3.
	// 14-Jun-2019 13:58:25
	template<typename T>
	void line_line_distance_gradient(
		T v01,
		T v02,
		T v03,
		T v11,
		T v12,
		T v13,
		T v21,
		T v22,
		T v23,
		T v31,
		T v32,
		T v33,
		T g[12])
	{
		T t11, t12, t13, t14, t15, t16, t17, t18, t19, t32, t33, t34, t35,
			t36, t37, t44, t45, t46, t75, t77, t76, t78, t79, t80, t81, t83;

		t11 = -v11 + v01;
		t12 = -v12 + v02;
		t13 = -v13 + v03;
		t14 = -v21 + v01;
		t15 = -v22 + v02;
		t16 = -v23 + v03;
		t17 = -v31 + v21;
		t18 = -v32 + v22;
		t19 = -v33 + v23;
		t32 = t14 * t18;
		t33 = t15 * t17;
		t34 = t14 * t19;
		t35 = t16 * t17;
		t36 = t15 * t19;
		t37 = t16 * t18;
		t44 = t11 * t18 + -(t12 * t17);
		t45 = t11 * t19 + -(t13 * t17);
		t46 = t12 * t19 + -(t13 * t18);
		t75 = 1.0 / ((t44 * t44 + t45 * t45) + t46 * t46);
		t77 = (t16 * t44 + t14 * t46) + -(t15 * t45);
		t76 = t75 * t75;
		t78 = t77 * t77;
		t79 = (t12 * t44 * 2.0 + t13 * t45 * 2.0) * t76 * t78;
		t80 = (t11 * t45 * 2.0 + t12 * t46 * 2.0) * t76 * t78;
		t81 = (t18 * t44 * 2.0 + t19 * t45 * 2.0) * t76 * t78;
		t18 = (t17 * t45 * 2.0 + t18 * t46 * 2.0) * t76 * t78;
		t83 = (t11 * t44 * 2.0 + -(t13 * t46 * 2.0)) * t76 * t78;
		t19 = (t17 * t44 * 2.0 + -(t19 * t46 * 2.0)) * t76 * t78;
		t76 = t75 * t77;
		g[0] = -t81 + t76 * ((-t36 + t37) + t46) * 2.0;
		g[1] = t19 - t76 * ((-t34 + t35) + t45) * 2.0;
		g[2] = t18 + t76 * ((-t32 + t33) + t44) * 2.0;
		g[3] = t81 + t76 * (t36 - t37) * 2.0;
		g[4] = -t19 - t76 * (t34 - t35) * 2.0;
		g[5] = -t18 + t76 * (t32 - t33) * 2.0;
		t17 = t12 * t16 + -(t13 * t15);
		g[6] = t79 - t76 * (t17 + t46) * 2.0;
		t18 = t11 * t16 + -(t13 * t14);
		g[7] = -t83 + t76 * (t18 + t45) * 2.0;
		t19 = t11 * t15 + -(t12 * t14);
		g[8] = -t80 - t76 * (t19 + t44) * 2.0;
		g[9] = -t79 + t76 * t17 * 2.0;
		g[10] = t83 - t76 * t18 * 2.0;
		g[11] = t80 + t76 * t19 * 2.0;
	}




	// This function was generated by the Symbolic Math Toolbox version 8.3.
	// 10-Jun-2019 18:02:39
	template<typename T>
	void point_line_distance_hessian_3D(
		T v01,
		T v02,
		T v03,
		T v11,
		T v12,
		T v13,
		T v21,
		T v22,
		T v23,
		T H[81])
	{
		T t17, t18, t19, t20, t21, t22, t23, t24, t25, t26, t27, t28, t35,
			t36, t37, t50, t51, t52, t53, t54, t55, t56, t62, t70, t71, t75,
			t79, t80, t84, t88, t38, t39, t40, t41, t42, t43, t44, t46, t48,
			t57, t58, t60, t63, t65, t67, t102, t103, t104, t162, t163, t164,
			t213, t214, t215, t216, t217, t218, t225, t226, t227, t229, t230,
			t311, t231, t232, t233, t234, t235, t236, t237, t238, t239, t240,
			t245, t279, t281, t282, t283, t287, t289, t247, t248, t249, t250,
			t251, t252, t253, t293, t295, t299, t300, t303, t304, t294, t297,
			t301, t302;

		t17 = -v11 + v01;
		t18 = -v12 + v02;
		t19 = -v13 + v03;
		t20 = -v21 + v01;
		t21 = -v22 + v02;
		t22 = -v23 + v03;
		t23 = -v21 + v11;
		t24 = -v22 + v12;
		t25 = -v23 + v13;
		t26 = v11 * 2.0 + -(v21 * 2.0);
		t27 = v12 * 2.0 + -(v22 * 2.0);
		t28 = v13 * 2.0 + -(v23 * 2.0);
		t35 = t23 * t23;
		t36 = t24 * t24;
		t37 = t25 * t25;
		t50 = t17 * t21;
		t51 = t18 * t20;
		t52 = t17 * t22;
		t53 = t19 * t20;
		t54 = t18 * t22;
		t55 = t19 * t21;
		t56 = t17 * t20 * 2.0;
		t62 = t18 * t21 * 2.0;
		t70 = t19 * t22 * 2.0;
		t71 = t17 * t23 * 2.0;
		t75 = t18 * t24 * 2.0;
		t79 = t19 * t25 * 2.0;
		t80 = t20 * t23 * 2.0;
		t84 = t21 * t24 * 2.0;
		t88 = t22 * t25 * 2.0;
		t38 = t17 * t17 * 2.0;
		t39 = t18 * t18 * 2.0;
		t40 = t19 * t19 * 2.0;
		t41 = t20 * t20 * 2.0;
		t42 = t21 * t21 * 2.0;
		t43 = t22 * t22 * 2.0;
		t44 = t35 * 2.0;
		t46 = t36 * 2.0;
		t48 = t37 * 2.0;
		t57 = t50 * 2.0;
		t58 = t51 * 2.0;
		t60 = t52 * 2.0;
		t63 = t53 * 2.0;
		t65 = t54 * 2.0;
		t67 = t55 * 2.0;
		t102 = 1.0 / ((t35 + t36) + t37);
		t36 = t50 + -t51;
		t35 = t52 + -t53;
		t37 = t54 + -t55;
		t103 = t102 * t102;
		t104 = pow(t102, 3.0);
		t162 = -(t23 * t24 * t102 * 2.0);
		t163 = -(t23 * t25 * t102 * 2.0);
		t164 = -(t24 * t25 * t102 * 2.0);
		t213 = t18 * t36 * 2.0 + t19 * t35 * 2.0;
		t214 = t17 * t35 * 2.0 + t18 * t37 * 2.0;
		t215 = t21 * t36 * 2.0 + t22 * t35 * 2.0;
		t216 = t20 * t35 * 2.0 + t21 * t37 * 2.0;
		t217 = t24 * t36 * 2.0 + t25 * t35 * 2.0;
		t218 = t23 * t35 * 2.0 + t24 * t37 * 2.0;
		t35 = (t36 * t36 + t35 * t35) + t37 * t37;
		t225 = t17 * t36 * 2.0 + -(t19 * t37 * 2.0);
		t226 = t20 * t36 * 2.0 + -(t22 * t37 * 2.0);
		t227 = t23 * t36 * 2.0 + -(t25 * t37 * 2.0);
		t36 = t26 * t103;
		t229 = t36 * t213;
		t37 = t27 * t103;
		t230 = t37 * t213;
		t311 = t28 * t103;
		t231 = t311 * t213;
		t232 = t36 * t214;
		t233 = t37 * t214;
		t234 = t311 * t214;
		t235 = t36 * t215;
		t236 = t37 * t215;
		t237 = t311 * t215;
		t238 = t36 * t216;
		t239 = t37 * t216;
		t240 = t311 * t216;
		t214 = t36 * t217;
		t215 = t37 * t217;
		t216 = t311 * t217;
		t217 = t36 * t218;
		t245 = t37 * t218;
		t213 = t311 * t218;
		t279 = t103 * t35 * 2.0;
		t281 = t26 * t26 * t104 * t35 * 2.0;
		t282 = t27 * t27 * t104 * t35 * 2.0;
		t283 = t28 * t28 * t104 * t35 * 2.0;
		t287 = t26 * t27 * t104 * t35 * 2.0;
		t218 = t26 * t28 * t104 * t35 * 2.0;
		t289 = t27 * t28 * t104 * t35 * 2.0;
		t247 = t36 * t225;
		t248 = t37 * t225;
		t249 = t311 * t225;
		t250 = t36 * t226;
		t251 = t37 * t226;
		t252 = t311 * t226;
		t253 = t36 * t227;
		t35 = t37 * t227;
		t36 = t311 * t227;
		t293 = t102 * (t75 + t79) + t214;
		t295 = -(t102 * (t80 + t84)) + t213;
		t299 = t102 * ((t63 + t22 * t23 * 2.0) + -t60) + t217;
		t300 = t102 * ((t67 + t22 * t24 * 2.0) + -t65) + t245;
		t303 = -(t102 * ((t57 + t17 * t24 * 2.0) + -t58)) + t215;
		t304 = -(t102 * ((t60 + t17 * t25 * 2.0) + -t63)) + t216;
		t294 = t102 * (t71 + t75) + -t213;
		t297 = -(t102 * (t80 + t88)) + t35;
		t88 = -(t102 * (t84 + t88)) + -t214;
		t301 = t102 * ((t58 + t21 * t23 * 2.0) + -t57) + t253;
		t302 = t102 * ((t65 + t21 * t25 * 2.0) + -t67) + t36;
		t84 = t102 * ((t57 + t20 * t24 * 2.0) + -t58) + -t215;
		t80 = t102 * ((t60 + t20 * t25 * 2.0) + -t63) + -t216;
		t75 = -(t102 * ((t63 + t19 * t23 * 2.0) + -t60)) + -t217;
		t227 = -(t102 * ((t67 + t19 * t24 * 2.0) + -t65)) + -t245;
		t311 = ((-(t17 * t19 * t102 * 2.0) + t231) + -t232) + t218;
		t245 = ((-(t20 * t22 * t102 * 2.0) + t237) + -t238) + t218;
		t226 = ((-t102 * (t67 - t54 * 4.0) + t233) + t252) + -t289;
		t28 = ((-t102 * (t63 - t52 * 4.0) + t232) + -t237) + -t218;
		t27 = ((-t102 * (t58 - t50 * 4.0) + t247) + -t236) + -t287;
		t225 = ((-(t102 * (t65 + -(t55 * 4.0))) + t239) + t249) + -t289;
		t26 = ((-(t102 * (t60 + -(t53 * 4.0))) + t238) + -t231) + -t218;
		t103 = ((-(t102 * (t57 + -(t51 * 4.0))) + t250) + -t230) + -t287;
		t104 = (((-(t102 * (t56 + t62)) + t234) + t240) + t279) + -t283;
		t218 = (((-(t102 * (t56 + t70)) + t248) + t251) + t279) + -t282;
		t217 = (((-(t102 * (t62 + t70)) + -t229) + -t235) + t279) + -t281;
		t216 = t102 * (t71 + t79) + -t35;
		t215 = -(t102 * ((t58 + t18 * t23 * 2.0) + -t57)) + -t253;
		t214 = -(t102 * ((t65 + t18 * t25 * 2.0) + -t67)) + -t36;
		t213 = ((-(t17 * t18 * t102 * 2.0) + t230) + -t247) + t287;
		t37 = ((-(t20 * t21 * t102 * 2.0) + t236) + -t250) + t287;
		t36 = ((-(t18 * t19 * t102 * 2.0) + -t233) + -t249) + t289;
		t35 = ((-(t21 * t22 * t102 * 2.0) + -t239) + -t252) + t289;
		H[0] = t102 * (t46 + t48);
		H[1] = t162;
		H[2] = t163;
		H[3] = t88;
		H[4] = t84;
		H[5] = t80;
		H[6] = t293;
		H[7] = t303;
		H[8] = t304;
		H[9] = t162;
		H[10] = t102 * (t44 + t48);
		H[11] = t164;
		H[12] = t301;
		H[13] = t297;
		H[14] = t302;
		H[15] = t215;
		H[16] = t216;
		H[17] = t214;
		H[18] = t163;
		H[19] = t164;
		H[20] = t102 * (t44 + t46);
		H[21] = t299;
		H[22] = t300;
		H[23] = t295;
		H[24] = t75;
		H[25] = t227;
		H[26] = t294;
		H[27] = t88;
		H[28] = t301;
		H[29] = t299;
		H[30] = ((t235 * 2.0 + -t279) + t281) + t102 * (t42 + t43);
		H[31] = t37;
		H[32] = t245;
		H[33] = t217;
		H[34] = t27;
		H[35] = t28;
		H[36] = t84;
		H[37] = t297;
		H[38] = t300;
		H[39] = t37;
		H[40] = ((t251 * -2.0 + -t279) + t282) + t102 * (t41 + t43);
		H[41] = t35;
		H[42] = t103;
		H[43] = t218;
		H[44] = t226;
		H[45] = t80;
		H[46] = t302;
		H[47] = t295;
		H[48] = t245;
		H[49] = t35;
		H[50] = ((t240 * -2.0 + -t279) + t283) + t102 * (t41 + t42);
		H[51] = t26;
		H[52] = t225;
		H[53] = t104;
		H[54] = t293;
		H[55] = t215;
		H[56] = t75;
		H[57] = t217;
		H[58] = t103;
		H[59] = t26;
		H[60] = ((t229 * 2.0 + -t279) + t281) + t102 * (t39 + t40);
		H[61] = t213;
		H[62] = t311;
		H[63] = t303;
		H[64] = t216;
		H[65] = t227;
		H[66] = t27;
		H[67] = t218;
		H[68] = t225;
		H[69] = t213;
		H[70] = ((t248 * -2.0 + -t279) + t282) + t102 * (t38 + t40);
		H[71] = t36;
		H[72] = t304;
		H[73] = t214;
		H[74] = t294;
		H[75] = t28;
		H[76] = t226;
		H[77] = t104;
		H[78] = t311;
		H[79] = t36;
		H[80] = ((t234 * -2.0 + -t279) + t283) + t102 * (t38 + t39);
	}


	// This function was generated by the Symbolic Math Toolbox version 8.3.
	// 14-Jun-2019 13:58:38
	template<typename T>
	void line_line_distance_hessian(
		T v01,
		T v02,
		T v03,
		T v11,
		T v12,
		T v13,
		T v21,
		T v22,
		T v23,
		T v31,
		T v32,
		T v33,
		T H[144])
	{
		T t11, t12, t13, t14, t15, t16, t26, t27, t28, t47, t48, t49, t50,
			t51, t52, t53, t54, t55, t56, t57, t58, t59, t65, t73, t35, t36,
			t37, t38, t39, t40, t98, t99, t100, t101, t103, t105, t107, t108,
			t109, t137, t138, t139, t140, t141, t142, t143, t144, t145, t146,
			t147, t148, t156, t159, t157, t262, t263, t264, t265, t266, t267,
			t268, t269, t270, t271, t272, t273, t274, t275, t276, t277, t278,
			t279, t298, t299, t300, t301, t302, t303, t310, t311, t312, t313,
			t314, t315, t322, t323, t325, t326, t327, t328, t329, t330, t335,
			t337, t339, t340, t341, t342, t343, t345, t348, t353, t356, t358,
			t359, t360, t362, t367, t368, t369, t371, t374, t377, t382, t386,
			t387, t398, t399, t403, t408, t423, t424, t427, t428, t431, t432,
			t433, t434, t437, t438, t441, t442, t446, t451, t455, t456, t467,
			t468, t472, t477, t491, t492, t495, t497, t499, t500, t503, t504,
			t506, t508, t550, t568, t519_tmp, b_t519_tmp, t519, t520_tmp,
			b_t520_tmp, t520, t521_tmp, b_t521_tmp, t521, t522_tmp, b_t522_tmp,
			t522, t523_tmp, b_t523_tmp, t523, t524_tmp, b_t524_tmp, t524, t525,
			t526, t527, t528, t529, t530, t531, t532, t533, t534, t535, t536,
			t537, t538, t539, t540, t542, t543, t544;

		t11 = -v11 + v01;
		t12 = -v12 + v02;
		t13 = -v13 + v03;
		t14 = -v21 + v01;
		t15 = -v22 + v02;
		t16 = -v23 + v03;
		t26 = -v31 + v21;
		t27 = -v32 + v22;
		t28 = -v33 + v23;
		t47 = t11 * t27;
		t48 = t12 * t26;
		t49 = t11 * t28;
		t50 = t13 * t26;
		t51 = t12 * t28;
		t52 = t13 * t27;
		t53 = t14 * t27;
		t54 = t15 * t26;
		t55 = t14 * t28;
		t56 = t16 * t26;
		t57 = t15 * t28;
		t58 = t16 * t27;
		t59 = t11 * t26 * 2.0;
		t65 = t12 * t27 * 2.0;
		t73 = t13 * t28 * 2.0;
		t35 = t11 * t11 * 2.0;
		t36 = t12 * t12 * 2.0;
		t37 = t13 * t13 * 2.0;
		t38 = t26 * t26 * 2.0;
		t39 = t27 * t27 * 2.0;
		t40 = t28 * t28 * 2.0;
		t98 = t11 * t15 + -(t12 * t14);
		t99 = t11 * t16 + -(t13 * t14);
		t100 = t12 * t16 + -(t13 * t15);
		t101 = t47 + -t48;
		t103 = t49 + -t50;
		t105 = t51 + -t52;
		t107 = t53 + -t54;
		t108 = t55 + -t56;
		t109 = t57 + -t58;
		t137 = t98 + t101;
		t138 = t99 + t103;
		t139 = t100 + t105;
		t140 = (t54 + -t53) + t101;
		t141 = (t56 + -t55) + t103;
		t142 = (t58 + -t57) + t105;
		t143 = t12 * t101 * 2.0 + t13 * t103 * 2.0;
		t144 = t11 * t103 * 2.0 + t12 * t105 * 2.0;
		t145 = t27 * t101 * 2.0 + t28 * t103 * 2.0;
		t146 = t26 * t103 * 2.0 + t27 * t105 * 2.0;
		t147 = t11 * t101 * 2.0 + -(t13 * t105 * 2.0);
		t148 = t26 * t101 * 2.0 + -(t28 * t105 * 2.0);
		t156 = 1.0 / ((t101 * t101 + t103 * t103) + t105 * t105);
		t159 = (t16 * t101 + t14 * t105) + -(t15 * t103);
		t157 = t156 * t156;
		t57 = pow(t156, 3.0);
		t58 = t159 * t159;
		t262 = t11 * t156 * t159 * 2.0;
		t263 = t12 * t156 * t159 * 2.0;
		t264 = t13 * t156 * t159 * 2.0;
		t265 = t14 * t156 * t159 * 2.0;
		t266 = t15 * t156 * t159 * 2.0;
		t267 = t16 * t156 * t159 * 2.0;
		t268 = (-v31 + v01) * t156 * t159 * 2.0;
		t269 = (-v21 + v11) * t156 * t159 * 2.0;
		t270 = (-v32 + v02) * t156 * t159 * 2.0;
		t271 = (-v22 + v12) * t156 * t159 * 2.0;
		t272 = (-v33 + v03) * t156 * t159 * 2.0;
		t273 = (-v23 + v13) * t156 * t159 * 2.0;
		t274 = (-v31 + v11) * t156 * t159 * 2.0;
		t275 = (-v32 + v12) * t156 * t159 * 2.0;
		t276 = (-v33 + v13) * t156 * t159 * 2.0;
		t277 = t26 * t156 * t159 * 2.0;
		t278 = t27 * t156 * t159 * 2.0;
		t279 = t28 * t156 * t159 * 2.0;
		t298 = t11 * t12 * t157 * t58 * 2.0;
		t299 = t11 * t13 * t157 * t58 * 2.0;
		t300 = t12 * t13 * t157 * t58 * 2.0;
		t301 = t26 * t27 * t157 * t58 * 2.0;
		t302 = t26 * t28 * t157 * t58 * 2.0;
		t303 = t27 * t28 * t157 * t58 * 2.0;
		t310 = (t35 + t36) * t157 * t58;
		t311 = (t35 + t37) * t157 * t58;
		t312 = (t36 + t37) * t157 * t58;
		t313 = (t38 + t39) * t157 * t58;
		t314 = (t38 + t40) * t157 * t58;
		t315 = (t39 + t40) * t157 * t58;
		t322 = (t59 + t65) * t157 * t58;
		t323 = (t59 + t73) * t157 * t58;
		t59 = (t65 + t73) * t157 * t58;
		t325 = (t47 * 2.0 + -(t48 * 4.0)) * t157 * t58;
		t53 = -t157 * t58;
		t56 = t48 * 2.0 - t47 * 4.0;
		t326 = t53 * t56;
		t327 = (t49 * 2.0 + -(t50 * 4.0)) * t157 * t58;
		t55 = t50 * 2.0 - t49 * 4.0;
		t328 = t53 * t55;
		t329 = (t51 * 2.0 + -(t52 * 4.0)) * t157 * t58;
		t54 = t52 * 2.0 - t51 * 4.0;
		t330 = t53 * t54;
		t53 = t157 * t58;
		t335 = t53 * t56;
		t337 = t53 * t55;
		t339 = t53 * t54;
		t340 = t143 * t143 * t57 * t58 * 2.0;
		t341 = t144 * t144 * t57 * t58 * 2.0;
		t342 = t145 * t145 * t57 * t58 * 2.0;
		t343 = t146 * t146 * t57 * t58 * 2.0;
		t345 = t147 * t147 * t57 * t58 * 2.0;
		t348 = t148 * t148 * t57 * t58 * 2.0;
		t36 = t98 * t143 * t157 * t159 * 2.0;
		t353 = t99 * t143 * t157 * t159 * 2.0;
		t356 = t99 * t144 * t157 * t159 * 2.0;
		t65 = t100 * t144 * t157 * t159 * 2.0;
		t358 = t107 * t143 * t157 * t159 * 2.0;
		t359 = t98 * t145 * t157 * t159 * 2.0;
		t360 = t108 * t143 * t157 * t159 * 2.0;
		t54 = t107 * t144 * t157 * t159 * 2.0;
		t362 = t99 * t145 * t157 * t159 * 2.0;
		t53 = t98 * t146 * t157 * t159 * 2.0;
		t56 = t109 * t143 * t157 * t159 * 2.0;
		t27 = t108 * t144 * t157 * t159 * 2.0;
		t55 = t100 * t145 * t157 * t159 * 2.0;
		t367 = t99 * t146 * t157 * t159 * 2.0;
		t368 = t109 * t144 * t157 * t159 * 2.0;
		t369 = t100 * t146 * t157 * t159 * 2.0;
		t38 = t107 * t145 * t157 * t159 * 2.0;
		t371 = t108 * t145 * t157 * t159 * 2.0;
		t374 = t108 * t146 * t157 * t159 * 2.0;
		t28 = t109 * t146 * t157 * t159 * 2.0;
		t377 = t98 * t147 * t157 * t159 * 2.0;
		t382 = t100 * t147 * t157 * t159 * 2.0;
		t386 = t107 * t147 * t157 * t159 * 2.0;
		t387 = t98 * t148 * t157 * t159 * 2.0;
		t103 = t108 * t147 * t157 * t159 * 2.0;
		t101 = t99 * t148 * t157 * t159 * 2.0;
		t398 = t109 * t147 * t157 * t159 * 2.0;
		t399 = t100 * t148 * t157 * t159 * 2.0;
		t403 = t107 * t148 * t157 * t159 * 2.0;
		t408 = t109 * t148 * t157 * t159 * 2.0;
		t73 = t137 * t143 * t157 * t159 * 2.0;
		t423 = t138 * t143 * t157 * t159 * 2.0;
		t424 = t138 * t144 * t157 * t159 * 2.0;
		t37 = t139 * t144 * t157 * t159 * 2.0;
		t427 = t140 * t143 * t157 * t159 * 2.0;
		t428 = t137 * t145 * t157 * t159 * 2.0;
		t16 = t140 * t144 * t157 * t159 * 2.0;
		t11 = t137 * t146 * t157 * t159 * 2.0;
		t431 = t141 * t143 * t157 * t159 * 2.0;
		t432 = t138 * t145 * t157 * t159 * 2.0;
		t433 = t141 * t144 * t157 * t159 * 2.0;
		t434 = t138 * t146 * t157 * t159 * 2.0;
		t105 = t142 * t143 * t157 * t159 * 2.0;
		t14 = t139 * t145 * t157 * t159 * 2.0;
		t437 = t142 * t144 * t157 * t159 * 2.0;
		t438 = t139 * t146 * t157 * t159 * 2.0;
		t35 = t140 * t145 * t157 * t159 * 2.0;
		t441 = t141 * t145 * t157 * t159 * 2.0;
		t442 = t141 * t146 * t157 * t159 * 2.0;
		t39 = t142 * t146 * t157 * t159 * 2.0;
		t446 = t137 * t147 * t157 * t159 * 2.0;
		t451 = t139 * t147 * t157 * t159 * 2.0;
		t455 = t140 * t147 * t157 * t159 * 2.0;
		t456 = t137 * t148 * t157 * t159 * 2.0;
		t13 = t141 * t147 * t157 * t159 * 2.0;
		t26 = t138 * t148 * t157 * t159 * 2.0;
		t467 = t142 * t147 * t157 * t159 * 2.0;
		t468 = t139 * t148 * t157 * t159 * 2.0;
		t472 = t140 * t148 * t157 * t159 * 2.0;
		t477 = t142 * t148 * t157 * t159 * 2.0;
		t47 = t143 * t144 * t57 * t58 * 2.0;
		t15 = t143 * t145 * t57 * t58 * 2.0;
		t491 = t143 * t146 * t57 * t58 * 2.0;
		t492 = t144 * t145 * t57 * t58 * 2.0;
		t12 = t144 * t146 * t57 * t58 * 2.0;
		t40 = t145 * t146 * t57 * t58 * 2.0;
		t495 = t143 * t147 * t57 * t58 * 2.0;
		t497 = t144 * t147 * t57 * t58 * 2.0;
		t499 = t143 * t148 * t57 * t58 * 2.0;
		t500 = t145 * t147 * t57 * t58 * 2.0;
		t503 = t146 * t147 * t57 * t58 * 2.0;
		t504 = t144 * t148 * t57 * t58 * 2.0;
		t506 = t145 * t148 * t57 * t58 * 2.0;
		t508 = t146 * t148 * t57 * t58 * 2.0;
		t57 = t147 * t148 * t57 * t58 * 2.0;
		t550 =
			((((t98 * t109 * t156 * 2.0 + -t266) + t337) + t359) + t368) + t492;
		t568 =
			((((t108 * t137 * t156 * 2.0 + -t268) + t330) + t27) + t456) + t504;
		t519_tmp = t139 * t143 * t157 * t159;
		b_t519_tmp = t100 * t143 * t157 * t159;
		t519 =
			(((-(t100 * t139 * t156 * 2.0) + t312) + -t340) + b_t519_tmp * 2.0)
			+ t519_tmp * 2.0;
		t520_tmp = t140 * t146 * t157 * t159;
		b_t520_tmp = t107 * t146 * t157 * t159;
		t520 = (((t107 * t140 * t156 * 2.0 + t313) + -t343) + b_t520_tmp * 2.0)
			+ -(t520_tmp * 2.0);
		t521_tmp = t142 * t145 * t157 * t159;
		b_t521_tmp = t109 * t145 * t157 * t159;
		t521 =
			(((t109 * t142 * t156 * 2.0 + t315) + -t342) + -(b_t521_tmp * 2.0))
			+ t521_tmp * 2.0;
		t522_tmp = t137 * t144 * t157 * t159;
		b_t522_tmp = t98 * t144 * t157 * t159;
		t522 = (((-(t98 * t137 * t156 * 2.0) + t310) + -t341)
			+ -(b_t522_tmp * 2.0))
			+ -(t522_tmp * 2.0);
		t523_tmp = t138 * t147 * t157 * t159;
		b_t523_tmp = t99 * t147 * t157 * t159;
		t523 =
			(((-(t99 * t138 * t156 * 2.0) + t311) + -t345) + b_t523_tmp * 2.0)
			+ t523_tmp * 2.0;
		t524_tmp = t141 * t148 * t157 * t159;
		b_t524_tmp = t108 * t148 * t157 * t159;
		t524 =
			(((t108 * t141 * t156 * 2.0 + t314) + -t348) + -(b_t524_tmp * 2.0))
			+ t524_tmp * 2.0;
		t525 = (((t98 * t100 * t156 * 2.0 + t299) + t65) + -t36) + -t47;
		t526 = (((t107 * t109 * t156 * 2.0 + t302) + t38) + -t28) + -t40;
		t527 = (((-(t98 * t99 * t156 * 2.0) + t300) + t377) + -t356) + t497;
		t528 = (((-(t99 * t100 * t156 * 2.0) + t298) + t353) + t382) + -t495;
		t529 = (((-(t107 * t108 * t156 * 2.0) + t303) + t374) + -t403) + t508;
		t530 = (((-(t108 * t109 * t156 * 2.0) + t301) + -t371) + -t408) + -t506;
		t531 = (((t98 * t107 * t156 * 2.0 + t322) + t54) + -t53) + -t12;
		t532 = (((t100 * t109 * t156 * 2.0 + t59) + t55) + -t56) + -t15;
		t533 = (((t99 * t108 * t156 * 2.0 + t323) + t101) + -t103) + -t57;
		t534 = (((t98 * t140 * t156 * 2.0 + -t322) + t53) + t16) + t12;
		t535 = (((-(t107 * t137 * t156 * 2.0) + -t322) + -t54) + t11) + t12;
		t536 = (((t100 * t142 * t156 * 2.0 + -t59) + -t55) + -t105) + t15;
		t537 = (((-(t109 * t139 * t156 * 2.0) + -t59) + t56) + -t14) + t15;
		t538 = (((t99 * t141 * t156 * 2.0 + -t323) + -t101) + -t13) + t57;
		t539 = (((-(t108 * t138 * t156 * 2.0) + -t323) + t103) + -t26) + t57;
		t540 = (((t137 * t139 * t156 * 2.0 + t299) + t37) + -t73) + -t47;
		t148 = (((t140 * t142 * t156 * 2.0 + t302) + t39) + -t35) + -t40;
		t542 = (((-(t137 * t138 * t156 * 2.0) + t300) + t446) + -t424) + t497;
		t543 = (((-(t138 * t139 * t156 * 2.0) + t298) + t423) + t451) + -t495;
		t544 = (((-(t140 * t141 * t156 * 2.0) + t303) + t472) + -t442) + t508;
		t53 = (((-(t141 * t142 * t156 * 2.0) + t301) + t441) + t477) + -t506;
		t157 = (((-(t139 * t142 * t156 * 2.0) + t59) + t105) + t14) + -t15;
		t159 = (((-(t137 * t140 * t156 * 2.0) + t322) + -t16) + -t11) + -t12;
		t147 = (((-(t138 * t141 * t156 * 2.0) + t323) + t13) + t26) + -t57;
		t146 = ((((t100 * t107 * t156 * 2.0 + t266) + t327) + -t358) + -t369)
			+ t491;
		t145 = ((((-(t99 * t107 * t156 * 2.0) + -t265) + t329) + t367) + t386)
			+ -t503;
		t144 = ((((-(t100 * t108 * t156 * 2.0) + -t267) + t325) + t360) + -t399)
			+ t499;
		t143 = ((((-(t99 * t109 * t156 * 2.0) + t267) + t335) + -t362) + t398)
			+ t500;
		t52 = ((((-(t98 * t108 * t156 * 2.0) + t265) + t339) + -t27) + -t387)
			+ -t504;
		t51 =
			((((t109 * t140 * t156 * 2.0 + -t278) + -t302) + t28) + t35) + t40;
		t50 = ((((-(t98 * t139 * t156 * 2.0) + t263) + -t299) + t36) + -t37)
			+ t47;
		t49 =
			((((t107 * t142 * t156 * 2.0 + t278) + -t302) + -t38) + -t39) + t40;
		t48 = ((((-(t100 * t137 * t156 * 2.0) + -t263) + -t299) + -t65) + t73)
			+ t47;
		t47 = ((((t99 * t137 * t156 * 2.0 + t262) + -t300) + t356) + -t446)
			+ -t497;
		t73 = ((((t100 * t138 * t156 * 2.0 + t264) + -t298) + -t382) + -t423)
			+ t495;
		t65 = ((((-(t109 * t141 * t156 * 2.0) + t279) + -t301) + t408) + -t441)
			+ t506;
		t59 = ((((t98 * t138 * t156 * 2.0 + -t262) + -t300) + -t377) + t424)
			+ -t497;
		t40 = ((((t99 * t139 * t156 * 2.0 + -t264) + -t298) + -t353) + -t451)
			+ t495;
		t39 = ((((-(t107 * t141 * t156 * 2.0) + -t277) + -t303) + t403) + t442)
			+ -t508;
		t38 = ((((-(t108 * t142 * t156 * 2.0) + -t279) + -t301) + t371) + -t477)
			+ t506;
		t37 = ((((-(t108 * t140 * t156 * 2.0) + t277) + -t303) + -t374) + -t472)
			+ -t508;
		t36 = ((((t98 * t142 * t156 * 2.0 + t271) + t328) + -t359) + t437)
			+ -t492;
		t35 = ((((-(t109 * t137 * t156 * 2.0) + t270) + t328) + -t368) + -t428)
			+ -t492;
		t28 = ((((t100 * t140 * t156 * 2.0 + -t271) + -t327) + t369) + -t427)
			+ -t491;
		t27 = ((((-(t98 * t141 * t156 * 2.0) + -t269) + t330) + t387) + -t433)
			+ t504;
		t26 = ((((t109 * t138 * t156 * 2.0 + -t272) + t326) + -t398) + t432)
			+ -t500;
		t13 = ((((-(t107 * t139 * t156 * 2.0) + -t270) + -t327) + t358) + t438)
			+ -t491;
		t12 = ((((-(t99 * t142 * t156 * 2.0) + -t273) + t326) + t362) + t467)
			+ -t500;
		t11 = ((((-(t99 * t140 * t156 * 2.0) + t269) + -t329) + -t367) + t455)
			+ t503;
		t16 = ((((t107 * t138 * t156 * 2.0 + t268) + -t329) + -t386) + -t434)
			+ t503;
		t15 = ((((-(t100 * t141 * t156 * 2.0) + t273) + -t325) + t399) + t431)
			+ -t499;
		t14 = ((((t108 * t139 * t156 * 2.0 + t272) + -t325) + -t360) + t468)
			+ -t499;
		t105 = ((((-(t139 * t140 * t156 * 2.0) + t275) + t327) + t427) + -t438)
			+ t491;
		t103 = ((((t138 * t140 * t156 * 2.0 + -t274) + t329) + t434) + -t455)
			+ -t503;
		t101 = ((((-(t137 * t142 * t156 * 2.0) + -t275) + t337) + t428) + -t437)
			+ t492;
		t58 = ((((t139 * t141 * t156 * 2.0 + -t276) + t325) + -t431) + -t468)
			+ t499;
		t57 = ((((t137 * t141 * t156 * 2.0 + t274) + t339) + t433) + -t456)
			+ -t504;
		t56 = ((((t138 * t142 * t156 * 2.0 + t276) + t335) + -t432) + -t467)
			+ t500;
		t55 = -t315 + t342;
		H[0] = (t55 + t142 * t142 * t156 * 2.0) - t521_tmp * 4.0;
		H[1] = t53;
		H[2] = t148;
		H[3] = t521;
		H[4] = t38;
		H[5] = t49;
		H[6] = t157;
		H[7] = t56;
		H[8] = t101;
		H[9] = t536;
		H[10] = t12;
		H[11] = t36;
		H[12] = t53;
		t54 = -t314 + t348;
		H[13] = (t54 + t141 * t141 * t156 * 2.0) - t524_tmp * 4.0;
		H[14] = t544;
		H[15] = t65;
		H[16] = t524;
		H[17] = t39;
		H[18] = t58;
		H[19] = t147;
		H[20] = t57;
		H[21] = t15;
		H[22] = t538;
		H[23] = t27;
		H[24] = t148;
		H[25] = t544;
		t53 = -t313 + t343;
		H[26] = (t53 + t140 * t140 * t156 * 2.0) + t520_tmp * 4.0;
		H[27] = t51;
		H[28] = t37;
		H[29] = t520;
		H[30] = t105;
		H[31] = t103;
		H[32] = t159;
		H[33] = t28;
		H[34] = t11;
		H[35] = t534;
		H[36] = t521;
		H[37] = t65;
		H[38] = t51;
		H[39] = (t55 + t109 * t109 * t156 * 2.0) + b_t521_tmp * 4.0;
		H[40] = t530;
		H[41] = t526;
		H[42] = t537;
		H[43] = t26;
		H[44] = t35;
		H[45] = t532;
		H[46] = t143;
		H[47] = t550;
		H[48] = t38;
		H[49] = t524;
		H[50] = t37;
		H[51] = t530;
		H[52] = (t54 + t108 * t108 * t156 * 2.0) + b_t524_tmp * 4.0;
		H[53] = t529;
		H[54] = t14;
		H[55] = t539;
		H[56] = t568;
		H[57] = t144;
		H[58] = t533;
		H[59] = t52;
		H[60] = t49;
		H[61] = t39;
		H[62] = t520;
		H[63] = t526;
		H[64] = t529;
		H[65] = (t53 + t107 * t107 * t156 * 2.0) - b_t520_tmp * 4.0;
		H[66] = t13;
		H[67] = t16;
		H[68] = t535;
		H[69] = t146;
		H[70] = t145;
		H[71] = t531;
		H[72] = t157;
		H[73] = t58;
		H[74] = t105;
		H[75] = t537;
		H[76] = t14;
		H[77] = t13;
		t55 = -t312 + t340;
		H[78] = (t55 + t139 * t139 * t156 * 2.0) - t519_tmp * 4.0;
		H[79] = t543;
		H[80] = t540;
		H[81] = t519;
		H[82] = t40;
		H[83] = t50;
		H[84] = t56;
		H[85] = t147;
		H[86] = t103;
		H[87] = t26;
		H[88] = t539;
		H[89] = t16;
		H[90] = t543;
		t54 = -t311 + t345;
		H[91] = (t54 + t138 * t138 * t156 * 2.0) - t523_tmp * 4.0;
		H[92] = t542;
		H[93] = t73;
		H[94] = t523;
		H[95] = t59;
		H[96] = t101;
		H[97] = t57;
		H[98] = t159;
		H[99] = t35;
		H[100] = t568;
		H[101] = t535;
		H[102] = t540;
		H[103] = t542;
		t53 = -t310 + t341;
		H[104] = (t53 + t137 * t137 * t156 * 2.0) + t522_tmp * 4.0;
		H[105] = t48;
		H[106] = t47;
		H[107] = t522;
		H[108] = t536;
		H[109] = t15;
		H[110] = t28;
		H[111] = t532;
		H[112] = t144;
		H[113] = t146;
		H[114] = t519;
		H[115] = t73;
		H[116] = t48;
		H[117] = (t55 + t100 * t100 * t156 * 2.0) - b_t519_tmp * 4.0;
		H[118] = t528;
		H[119] = t525;
		H[120] = t12;
		H[121] = t538;
		H[122] = t11;
		H[123] = t143;
		H[124] = t533;
		H[125] = t145;
		H[126] = t40;
		H[127] = t523;
		H[128] = t47;
		H[129] = t528;
		H[130] = (t54 + t99 * t99 * t156 * 2.0) - b_t523_tmp * 4.0;
		H[131] = t527;
		H[132] = t36;
		H[133] = t27;
		H[134] = t534;
		H[135] = t550;
		H[136] = t52;
		H[137] = t531;
		H[138] = t50;
		H[139] = t59;
		H[140] = t522;
		H[141] = t525;
		H[142] = t527;
		H[143] = (t53 + t98 * t98 * t156 * 2.0) + b_t522_tmp * 4.0;
	}

} // namespace autogen



template<typename T>
Eigen::Matrix<T, 3, 2> compute_tangent_basis_edge_edge(
	const Eigen::Vector3<T>& ea0,
	const Eigen::Vector3<T>& ea1,
	const Eigen::Vector3<T>& eb0,
	const Eigen::Vector3<T>& eb1)
{
	const Eigen::Vector3<T> ea = ea1 - ea0; // Edge A direction
	Eigen::Vector3<T> normal = ea.cross(eb1 - eb0);
	if (normal.norm() == 0) {
		normal << 1.0, 0.0, 0.0;
	}

	Eigen::Matrix<T, 3, 2> basis;
	// The first basis vector is along edge A.
	basis.col(0) = ea.normalized();
	// The second basis vector is orthogonal to the first and the edge-edge
	// normal.
	basis.col(1) = normal.cross(ea).normalized();
	return basis;
}

template<typename T>
Eigen::Vector2<T> compute_lerp_alpha_edge_edge_closest_point(
	const Eigen::Vector3<T>& ea0,
	const Eigen::Vector3<T>& ea1,
	const Eigen::Vector3<T>& eb0,
	const Eigen::Vector3<T>& eb1)
{

	Eigen::Vector3<T> u = ea1 - ea0;
	Eigen::Vector3<T> v = eb1 - eb0;
	Eigen::Vector3<T> w0 = ea0 - eb0;

	T a = u.dot(u);  // u · u
	T b = u.dot(v);  // u · v
	T c = v.dot(v);  // v · v
	T d = u.dot(w0); // u · w0
	T e = v.dot(w0); // v · w0

	T denom = a * c - b * b;

	Eigen::Vector2<T> alpha_beta;
	if (abs(denom) > 1e-12) {
		// 정상적인 경우
		alpha_beta << 
			(b * e - c * d) / denom,
			(a * e - b * d) / denom;
	}
	else {
		// 거의 평행하거나 퇴화된 경우: 중앙값 사용
		alpha_beta << 0.5, 0.5;
	}

	// Clamp to [0, 1]
	//alpha_beta[0] = std::clamp(alpha_beta[0], 0.0, 1.0);
	//alpha_beta[1] = std::clamp(alpha_beta[1], 0.0, 1.0);

	//return alpha_beta;

	const Eigen::Vector3<T> eb_to_ea = ea0 - eb0;
	const Eigen::Vector3<T> ea = ea1 - ea0;
	const Eigen::Vector3<T> eb = eb1 - eb0;

	Eigen::Matrix<T, 2, 2> coefMtr;
	coefMtr(0, 0) = ea.dot(ea);
	coefMtr(0, 1) = coefMtr(1, 0) = -eb.dot(ea);
	coefMtr(1, 1) = eb.dot(eb);

	Eigen::Vector2<T> rhs;
	rhs[0] = -eb_to_ea.dot(ea);
	rhs[1] = eb_to_ea.dot(eb);

	T coeff0 = coefMtr(0, 0)* coefMtr(1, 1) - coefMtr(0, 1) * coefMtr(1, 0);
	Eigen::Matrix<T, 2, 2> coefMtr_inv;
	coefMtr_inv(0, 0) = coefMtr(1, 1) / coeff0;
	coefMtr_inv(0, 1) = -coefMtr(0, 1) / coeff0;
	coefMtr_inv(1, 0) = -coefMtr(1, 0) / coeff0;
	coefMtr_inv(1, 1) = coefMtr(0, 0) / coeff0;
	const Eigen::Vector2<T> x = coefMtr_inv * rhs;// coefMtr.ldlt().solve(rhs);
	//std::cout << coefMtr << std::endl;
	//std::cout << rhs.transpose() << std::endl;
	//std::cout << x.transpose() << std::endl;
	//std::cout << (coefMtr * x - rhs).squaredNorm() << std::endl;
	//assert(std::isfinite(x.squaredNorm()));
	//assert((coefMtr * x - rhs).squaredNorm() < 1.e-6);

	//std::cout << "alpha_beta : " << alpha_beta << std::endl;
	//std::cout << "x : " << x << std::endl;

	return x;
}

//void compute_edge_edge_closest_parameters(
//	const Vector3d& v0, const Vector3d& v1,
//	const Vector3d& v2, const Vector3d& v3,
//	double& alpha, double& beta)
//{
//	Vector3d u = v1 - v0;
//	Vector3d v = v3 - v2;
//	Vector3d w0 = v0 - v2;
//
//	double a = u.dot(u);  // u · u
//	double b = u.dot(v);  // u · v
//	double c = v.dot(v);  // v · v
//	double d = u.dot(w0); // u · w0
//	double e = v.dot(w0); // v · w0
//
//	double denom = a * c - b * b;
//
//	if (std::abs(denom) > 1e-12) {
//		// 정상적인 경우
//		alpha = (b * e - c * d) / denom;
//		beta = (a * e - b * d) / denom;
//	}
//	else {
//		// 거의 평행하거나 퇴화된 경우: 중앙값 사용
//		alpha = 0.5;
//		beta = 0.5;
//	}
//
//	// Clamp to [0, 1]
//	alpha = std::clamp(alpha, 0.0, 1.0);
//	beta = std::clamp(beta, 0.0, 1.0);
//}



template<typename T>
Eigen::Vector3<T> lerp(
	const Eigen::Vector3<T>& a_value,
	const Eigen::Vector3<T>& b_value,
	const double& alpha)
{
	return (a_value * (1.0 - alpha) + b_value * alpha);
}



/// @brief Closest pair between two edges.
enum class EdgeEdgeDistanceType {
	/// The edges are closest at vertex 0 of edge A and 0 of edge B.
	EA0_EB0,
	/// The edges are closest at vertex 0 of edge A and 1 of edge B.
	EA0_EB1,
	/// The edges are closest at vertex 1 of edge A and 0 of edge B.
	EA1_EB0,
	/// The edges are closest at vertex 1 of edge A and 1 of edge B.
	EA1_EB1,
	/// The edges are closest at the interior of edge A and vertex 0 of edge B.
	EA_EB0,
	/// The edges are closest at the interior of edge A and vertex 1 of edge B.
	EA_EB1,
	/// The edges are closest at vertex 0 of edge A and the interior of edge B.
	EA0_EB,
	/// The edges are closest at vertex 1 of edge A and the interior of edge B.
	EA1_EB,
	/// The edges are closest at an interior point of edge A and B.
	EA_EB,
	/// Automatically determine the closest pair.
	AUTO
};


template<typename T>
EdgeEdgeDistanceType edge_edge_parallel_distance_type(
	const Eigen::Vector3<T>& ea0,
	const Eigen::Vector3<T>& ea1,
	const Eigen::Vector3<T>& eb0,
	const Eigen::Vector3<T>& eb1)
{
	const Eigen::Vector3<T> ea = ea1 - ea0;
	const T alpha = (eb0 - ea0).dot(ea) / ea.squaredNorm();
	const T beta = (eb1 - ea0).dot(ea) / ea.squaredNorm();

	uint8_t eac; // 0: EA0, 1: EA1, 2: EA
	uint8_t ebc; // 0: EB0, 1: EB1, 2: EB
	if (alpha < 0) {
		eac = (0 <= beta && beta <= 1) ? 2 : 0;
		ebc = (beta <= alpha) ? 0 : (beta <= 1 ? 1 : 2);
	}
	else if (alpha > 1) {
		eac = (0 <= beta && beta <= 1) ? 2 : 1;
		ebc = (beta >= alpha) ? 0 : (0 <= beta ? 1 : 2);
	}
	else {
		eac = 2;
		ebc = 0;
	}

	// f(0, 0) = 0000 = 0 -> EA0_EB0
	// f(0, 1) = 0001 = 1 -> EA0_EB1
	// f(1, 0) = 0010 = 2 -> EA1_EB0
	// f(1, 1) = 0011 = 3 -> EA1_EB1
	// f(2, 0) = 0100 = 4 -> EA_EB0
	// f(2, 1) = 0101 = 5 -> EA_EB1
	// f(0, 2) = 0110 = 6 -> EA0_EB
	// f(1, 2) = 0111 = 7 -> EA1_EB
	// f(2, 2) = 1000 = 8 -> EA_EB

	assert(eac != 2 || ebc != 2); // This case results in a degenerate line-line
	return EdgeEdgeDistanceType(ebc < 2 ? (eac << 1 | ebc) : (6 + eac));
}

// A more robust implementation of http://geomalgorithms.com/a07-_distance.html
template<typename T>
EdgeEdgeDistanceType edge_edge_distance_type(
	const Eigen::Vector3<T>& ea0,
	const Eigen::Vector3<T>& ea1,
	const Eigen::Vector3<T>& eb0,
	const Eigen::Vector3<T>& eb1)
{
	constexpr double PARALLEL_THRESHOLD = 1.0e-20;

	const Eigen::Vector3<T> u = ea1 - ea0;
	const Eigen::Vector3<T> v = eb1 - eb0;
	const Eigen::Vector3<T> w = ea0 - eb0;

	const T a = u.squaredNorm(); // always ≥ 0
	const T b = u.dot(v);
	const T c = v.squaredNorm(); // always ≥ 0
	const T d = u.dot(w);
	const T e = v.dot(w);
	const T D = a * c - b * b; // always ≥ 0

	// Degenerate cases should not happen in practice, but we handle them
	if (a == 0.0 && c == 0.0) {
		return EdgeEdgeDistanceType::EA0_EB0;
	}
	else if (a == 0.0) {
		return EdgeEdgeDistanceType::EA0_EB;
	}
	else if (c == 0.0) {
		return EdgeEdgeDistanceType::EA_EB0;
	}

	// Special handling for parallel edges
	const T parallel_tolerance = PARALLEL_THRESHOLD * max(1.0, a * c);
	if (u.cross(v).squaredNorm() < parallel_tolerance) {
		return edge_edge_parallel_distance_type(ea0, ea1, eb0, eb1);
	}

	EdgeEdgeDistanceType default_case = EdgeEdgeDistanceType::EA_EB;

	// compute the line parameters of the two closest points
	const T sN = (b * e - c * d);
	T tN, tD;   // tc = tN / tD
	if (sN <= 0.0) { // sc < 0 ⟹ the s=0 edge is visible
		tN = e;
		tD = c;
		default_case = EdgeEdgeDistanceType::EA0_EB;
	}
	else if (sN >= D) { // sc > 1 ⟹ the s=1 edge is visible
		tN = e + b;
		tD = c;
		default_case = EdgeEdgeDistanceType::EA1_EB;
	}
	else {
		tN = (a * e - b * d);
		tD = D; // default tD = D ≥ 0
		if (tN > 0.0 && tN < tD
			&& u.cross(v).squaredNorm() < parallel_tolerance) {
			// avoid coplanar or nearly parallel EE
			if (sN < D / 2) {
				tN = e;
				tD = c;
				default_case = EdgeEdgeDistanceType::EA0_EB;
			}
			else {
				tN = e + b;
				tD = c;
				default_case = EdgeEdgeDistanceType::EA1_EB;
			}
		}
		// else default_case stays EdgeEdgeDistanceType::EA_EB
	}

	if (tN <= 0.0) { // tc < 0 ⟹ the t=0 edge is visible
		// recompute sc for this edge
		if (-d <= 0.0) {
			return EdgeEdgeDistanceType::EA0_EB0;
		}
		else if (-d >= a) {
			return EdgeEdgeDistanceType::EA1_EB0;
		}
		else {
			return EdgeEdgeDistanceType::EA_EB0;
		}
	}
	else if (tN >= tD) { // tc > 1 ⟹ the t=1 edge is visible
		// recompute sc for this edge
		if ((-d + b) <= 0.0) {
			return EdgeEdgeDistanceType::EA0_EB1;
		}
		else if ((-d + b) >= a) {
			return EdgeEdgeDistanceType::EA1_EB1;
		}
		else {
			return EdgeEdgeDistanceType::EA_EB1;
		}
	}

	return default_case;
}


template<typename T>
T point_point_distance(
	const Eigen::Vector3<T>& p0,
	const Eigen::Vector3<T>& p1)
{
	return (p1 - p0).squaredNorm();
}


template<typename T>
T point_line_distance(
	const Eigen::Vector3<T>& p,
	const Eigen::Vector3<T>& e0,
	const Eigen::Vector3<T>& e1)
{
	assert(p.size() == 2 || p.size() == 3);
	assert(e0.size() == 2 || e0.size() == 3);
	assert(e1.size() == 2 || e1.size() == 3);

	//if (p.size() == 2) {
	//	const Eigen::Vector2<T> e = e1 - e0;
	//	const T numerator =
	//		(e[1] * p[0] - e[0] * p[1] + e1[0] * e0[1] - e1[1] * e0[0]);
	//	return numerator * numerator / e.squaredNorm();
	//}
	//else {
		return (e0 - p).head<3>().cross((e1 - p).head<3>()).squaredNorm()
			/ (e1 - e0).squaredNorm();
	//}
}


template<typename T>
T line_line_distance(
	const Eigen::Vector3<T>& ea0,
	const Eigen::Vector3<T>& ea1,
	const Eigen::Vector3<T>& eb0,
	const Eigen::Vector3<T>& eb1)
{
	const Eigen::Vector3<T> normal = (ea1 - ea0).cross(eb1 - eb0);
	const T line_to_line = (eb0 - ea0).dot(normal);
	return line_to_line * line_to_line / normal.squaredNorm();
}


template<typename T>
T edge_edge_distance(
	const Eigen::Vector3<T>& ea0,
	const Eigen::Vector3<T>& ea1,
	const Eigen::Vector3<T>& eb0,
	const Eigen::Vector3<T>& eb1)
{
	//if (dtype == EdgeEdgeDistanceType::AUTO) {
		auto dtype = edge_edge_distance_type(ea0, ea1, eb0, eb1);
	//}

	switch (dtype) {
	case EdgeEdgeDistanceType::EA0_EB0:
		return point_point_distance(ea0, eb0);

	case EdgeEdgeDistanceType::EA0_EB1:
		return point_point_distance(ea0, eb1);

	case EdgeEdgeDistanceType::EA1_EB0:
		return point_point_distance(ea1, eb0);

	case EdgeEdgeDistanceType::EA1_EB1:
		return point_point_distance(ea1, eb1);

	case EdgeEdgeDistanceType::EA_EB0:
		return point_line_distance(eb0, ea0, ea1);

	case EdgeEdgeDistanceType::EA_EB1:
		return point_line_distance(eb1, ea0, ea1);

	case EdgeEdgeDistanceType::EA0_EB:
		return point_line_distance(ea0, eb0, eb1);

	case EdgeEdgeDistanceType::EA1_EB:
		return point_line_distance(ea1, eb0, eb1);

	case EdgeEdgeDistanceType::EA_EB:
		return line_line_distance(ea0, ea1, eb0, eb1);

	default:
		throw std::invalid_argument(
			"Invalid distance type for edge-edge distance!");
	}
}



template<typename T>
T edge_edge_mollifier_threshold(
	const Eigen::Vector3<T>& ea0_rest,
	const Eigen::Vector3<T>& ea1_rest,
	const Eigen::Vector3<T>& eb0_rest,
	const Eigen::Vector3<T>& eb1_rest)
{
	return 1e-3 * (ea0_rest - ea1_rest).squaredNorm()
		* (eb0_rest - eb1_rest).squaredNorm();
}


template<typename T>
T edge_edge_cross_squarednorm(
	const Eigen::Vector3<T>& ea0,
	const Eigen::Vector3<T>& ea1,
	const Eigen::Vector3<T>& eb0,
	const Eigen::Vector3<T>& eb1)
{
	return (ea1 - ea0).cross(eb1 - eb0).squaredNorm();
}


template<typename T>
T edge_edge_mollifier(const T x, const T eps_x)
{
	if (x < eps_x) {
		const T x_div_eps_x = x / eps_x;
		return (-x_div_eps_x + 2) * x_div_eps_x;
	}
	else {
		return 1;
	}
}



template<typename T>
T edge_edge_mollifier(
	const Eigen::Vector3<T>& ea0,
	const Eigen::Vector3<T>& ea1,
	const Eigen::Vector3<T>& eb0,
	const Eigen::Vector3<T>& eb1,
	const T eps_x)
{
	const T ee_cross_norm_sqr =
		edge_edge_cross_squarednorm(ea0, ea1, eb0, eb1);
	if (ee_cross_norm_sqr < eps_x) {
		return edge_edge_mollifier(ee_cross_norm_sqr, eps_x);
	}
	else {
		return 1;
	}
}



template<typename T>
Eigen::Vector<T, 6> point_point_distance_gradient(
	const Eigen::Vector3<T>& p0,
	const Eigen::Vector3<T>& p1)
{
	Eigen::Vector<T, 6> grad;

	grad.head(3) = 2.0 * (p0 - p1);
	grad.tail(3) = -grad.head(3);

	return grad;
}


template<typename T>
Eigen::Vector<T, 9> point_line_distance_gradient(
	const Eigen::Vector3<T>& p,
	const Eigen::Vector3<T>& e0,
	const Eigen::Vector3<T>& e1)
{

	Eigen::Vector<T, 9> grad;
	//if (dim == 2) {
	//	autogen::point_line_distance_gradient_2D(
	//		p[0], p[1], e0[0], e0[1], e1[0], e1[1], grad.data());
	//}
	//else {
		autogen::point_line_distance_gradient_3D(
			p[0], p[1], p[2], e0[0], e0[1], e0[2], e1[0], e1[1], e1[2],
			grad.data());
	//}
	return grad;
}


template<typename T>
Eigen::Vector<T, 12> line_line_distance_gradient(
	const Eigen::Vector3<T>& ea0,
	const Eigen::Vector3<T>& ea1,
	const Eigen::Vector3<T>& eb0,
	const Eigen::Vector3<T>& eb1)
{
	Eigen::Vector<T, 12> grad;
	autogen::line_line_distance_gradient(
		ea0[0], ea0[1], ea0[2], ea1[0], ea1[1], ea1[2], eb0[0], eb0[1], eb0[2],
		eb1[0], eb1[1], eb1[2], grad.data());
	return grad;
}



template<typename T>
Eigen::Vector<T, 12> edge_edge_distance_gradient(
	const Eigen::Vector3<T>& ea0,
	const Eigen::Vector3<T>& ea1,
	const Eigen::Vector3<T>& eb0,
	const Eigen::Vector3<T>& eb1)
{
	//if (dtype == EdgeEdgeDistanceType::AUTO) {
		auto dtype = edge_edge_distance_type(ea0, ea1, eb0, eb1);
	//}

	Eigen::Vector<T, 12> grad = Eigen::Vector<T, 12>::Zero();

	switch (dtype) {
	case EdgeEdgeDistanceType::EA0_EB0: {
		const Eigen::Vector<T, 6> local_grad = point_point_distance_gradient(ea0, eb0);
		grad.head<3>() = local_grad.head<3>();
		grad.segment<3>(6) = local_grad.tail<3>();
		break;
	}

	case EdgeEdgeDistanceType::EA0_EB1: {
		const Eigen::Vector<T, 6> local_grad = point_point_distance_gradient(ea0, eb1);
		grad.head<3>() = local_grad.head<3>();
		grad.tail<3>() = local_grad.tail<3>();
		break;
	}

	case EdgeEdgeDistanceType::EA1_EB0:
		grad.segment<6>(3) = point_point_distance_gradient(ea1, eb0);
		break;

	case EdgeEdgeDistanceType::EA1_EB1: {
		const Eigen::Vector<T, 6> local_grad = point_point_distance_gradient(ea1, eb1);
		grad.segment<3>(3) = local_grad.head<3>();
		grad.tail<3>() = local_grad.tail<3>();
		break;
	}

	case EdgeEdgeDistanceType::EA_EB0: {
		const Eigen::Vector<T, 9> local_grad = point_line_distance_gradient(eb0, ea0, ea1);
		grad.head<6>() = local_grad.tail<6>();
		grad.segment<3>(6) = local_grad.head<3>();
		break;
	}

	case EdgeEdgeDistanceType::EA_EB1: {
		const Eigen::Vector<T, 9> local_grad = point_line_distance_gradient(eb1, ea0, ea1);
		grad.head<6>() = local_grad.tail<6>();
		grad.tail<3>() = local_grad.head<3>();
		break;
	}

	case EdgeEdgeDistanceType::EA0_EB: {
		const Eigen::Vector<T, 9> local_grad = point_line_distance_gradient(ea0, eb0, eb1);
		grad.head<3>() = local_grad.head<3>();
		grad.tail<6>() = local_grad.tail<6>();
		break;
	}

	case EdgeEdgeDistanceType::EA1_EB:
		grad.tail<9>() = point_line_distance_gradient(ea1, eb0, eb1);
		break;

	case EdgeEdgeDistanceType::EA_EB:
		grad = line_line_distance_gradient(ea0, ea1, eb0, eb1);
		break;

	default:
		throw std::invalid_argument(
			"Invalid distance type for edge-edge distance gradient!");
	}

	return grad;
}



template<typename T>
T edge_edge_mollifier_gradient(const T x, const T eps_x)
{
	if (x < eps_x) {
		const T one_div_eps_x = 1 / eps_x;
		return 2 * one_div_eps_x * (-one_div_eps_x * x + 1);
	}
	else {
		return 0;
	}
}



template<typename T>
Eigen::Vector<T, 12> edge_edge_cross_squarednorm_gradient(
	const Eigen::Vector3<T>& ea0,
	const Eigen::Vector3<T>& ea1,
	const Eigen::Vector3<T>& eb0,
	const Eigen::Vector3<T>& eb1)
{
	Eigen::Vector<T, 12> grad;
	autogen::edge_edge_cross_squarednorm_gradient(
		ea0[0], ea0[1], ea0[2], ea1[0], ea1[1], ea1[2], eb0[0], eb0[1], eb0[2],
		eb1[0], eb1[1], eb1[2], grad.data());
	return grad;
}


template<typename T>
Eigen::Vector<T, 12> edge_edge_mollifier_gradient(
	const Eigen::Vector3<T>& ea0,
	const Eigen::Vector3<T>& ea1,
	const Eigen::Vector3<T>& eb0,
	const Eigen::Vector3<T>& eb1,
	const T eps_x)
{
	const T ee_cross_norm_sqr =
		edge_edge_cross_squarednorm(ea0, ea1, eb0, eb1);
	if (ee_cross_norm_sqr < eps_x) {
		return edge_edge_mollifier_gradient(ee_cross_norm_sqr, eps_x)
			* edge_edge_cross_squarednorm_gradient(ea0, ea1, eb0, eb1);
	}
	else {
		return Eigen::Vector<T, 12>::Zero();
	}
}


template<typename T>
T f0_SF(const T& s, const double& epsv)
{
	if (abs(s) >= epsv) {
		return s;
	}
	return s * s * (-s / (3.0 * epsv) + 1.0) / epsv + epsv / 3.0;
}


template<typename T>
Eigen::Matrix<T, 3, 12> edge_edge_relative_velocity_matrix(
	const int dim, const Eigen::Vector2<T>& coords)
{
	Eigen::Matrix<T, 3, 12> J = Eigen::Matrix<T, 3, 12>::Zero();
	J.leftCols(dim).diagonal().setConstant(1.0 - coords[0]);
	J.middleCols(dim, dim).diagonal().setConstant(coords[0]);
	J.middleCols(2 * dim, dim).diagonal().setConstant(coords[1] - 1.0);
	J.rightCols(dim).diagonal().setConstant(-coords[1]);
	return J;
}

template<typename T>
T f1_SF_over_x(const T& s, const double& epsv)
{
	if (abs(s) >= epsv) {
		return 1.0 / s;
	}
	return (-s / epsv + 2.0) / epsv;
}


template<typename T>
T df1_x_minus_f1_over_x3(const T& s, const double& epsv)
{
	if (abs(s) >= epsv) {
		return -1.0 / (s * s * s);
	}
	return -1.0 / (s * epsv * epsv);
}



template<typename T>
Eigen::Matrix<T, 6, 6> point_point_distance_hessian(
	const Eigen::Vector3<T>& p0,
	const Eigen::Vector3<T>& p1)
{
	int dim = p0.size();
	assert(p1.size() == dim);

	Eigen::Matrix<T, 6, 6> hess(2 * dim, 2 * dim);

	hess.setZero();
	hess.diagonal().setConstant(2.0);
	for (int i = 0; i < dim; i++) {
		hess(i, i + dim) = hess(i + dim, i) = -2;
	}

	return hess;
}

template<typename T>
Eigen::Matrix<T, 9, 9> point_line_distance_hessian(
	const Eigen::Vector3<T>& p,
	const Eigen::Vector3<T>& e0,
	const Eigen::Vector3<T>& e1)
{
	const int dim = p.size();
	assert(e0.size() == dim);
	assert(e1.size() == dim);

	Eigen::Matrix<T, 9, 9> hess(3 * dim, 3 * dim);
	//if (dim == 2) {
	//	autogen::point_line_distance_hessian_2D(
	//		p[0], p[1], e0[0], e0[1], e1[0], e1[1], hess.data());
	//}
	//else {
		autogen::point_line_distance_hessian_3D(
			p[0], p[1], p[2], e0[0], e0[1], e0[2], e1[0], e1[1], e1[2],
			hess.data());
	//}
	return hess;
}

template<typename T>
Eigen::Matrix<T, 12, 12> line_line_distance_hessian(
	const Eigen::Vector3<T>& ea0,
	const Eigen::Vector3<T>& ea1,
	const Eigen::Vector3<T>& eb0,
	const Eigen::Vector3<T>& eb1)
{
	Eigen::Matrix<T, 12, 12> hess;
	autogen::line_line_distance_hessian(
		ea0[0], ea0[1], ea0[2], ea1[0], ea1[1], ea1[2], eb0[0], eb0[1], eb0[2],
		eb1[0], eb1[1], eb1[2], hess.data());
	return hess;
}


template<typename T>
Eigen::Matrix<T, 12, 12> edge_edge_distance_hessian(
	const Eigen::Vector3<T>& ea0,
	const Eigen::Vector3<T>& ea1,
	const Eigen::Vector3<T>& eb0,
	const Eigen::Vector3<T>& eb1)
{
	//if (dtype == EdgeEdgeDistanceType::AUTO) {
		auto dtype = edge_edge_distance_type(ea0, ea1, eb0, eb1);
	//}

	Eigen::Matrix<T, 12, 12> hess = Eigen::Matrix<T, 12, 12>::Zero();

	switch (dtype) {
	case EdgeEdgeDistanceType::EA0_EB0: {
		const Eigen::Matrix<T, 6, 6> local_hess = point_point_distance_hessian(ea0, eb0);
		hess.topLeftCorner<3, 3>() = local_hess.topLeftCorner<3, 3>();
		hess.block<3, 3>(0, 6) = local_hess.topRightCorner<3, 3>();
		hess.block<3, 3>(6, 0) = local_hess.bottomLeftCorner<3, 3>();
		hess.block<3, 3>(6, 6) = local_hess.bottomRightCorner<3, 3>();
		break;
	}

	case EdgeEdgeDistanceType::EA0_EB1: {
		const Eigen::Matrix<T, 6, 6> local_hess = point_point_distance_hessian(ea0, eb1);
		hess.topLeftCorner<3, 3>() = local_hess.topLeftCorner<3, 3>();
		hess.topRightCorner<3, 3>() = local_hess.topRightCorner<3, 3>();
		hess.bottomLeftCorner<3, 3>() = local_hess.bottomLeftCorner<3, 3>();
		hess.bottomRightCorner<3, 3>() = local_hess.bottomRightCorner<3, 3>();
		break;
	}

	case EdgeEdgeDistanceType::EA1_EB0:
		hess.block<6, 6>(3, 3) = point_point_distance_hessian(ea1, eb0);
		break;

	case EdgeEdgeDistanceType::EA1_EB1: {
		const Eigen::Matrix<T, 6, 6> local_hess = point_point_distance_hessian(ea1, eb1);
		hess.block<3, 3>(3, 3) = local_hess.topLeftCorner<3, 3>();
		hess.block<3, 3>(3, 9) = local_hess.topRightCorner<3, 3>();
		hess.block<3, 3>(9, 3) = local_hess.bottomLeftCorner<3, 3>();
		hess.bottomRightCorner<3, 3>() = local_hess.bottomRightCorner<3, 3>();
		break;
	}

	case EdgeEdgeDistanceType::EA_EB0: {
		const Eigen::Matrix<T, 9, 9> local_hess = point_line_distance_hessian(eb0, ea0, ea1);
		hess.topLeftCorner<6, 6>() = local_hess.bottomRightCorner<6, 6>();
		hess.block<3, 6>(6, 0) = local_hess.topRightCorner<3, 6>();
		hess.block<6, 3>(0, 6) = local_hess.bottomLeftCorner<6, 3>();
		hess.block<3, 3>(6, 6) = local_hess.topLeftCorner<3, 3>();
		break;
	}

	case EdgeEdgeDistanceType::EA_EB1: {
		const Eigen::Matrix<T, 9, 9> local_hess = point_line_distance_hessian(eb1, ea0, ea1);
		hess.topLeftCorner<6, 6>() = local_hess.bottomRightCorner<6, 6>();
		hess.topRightCorner<6, 3>() = local_hess.bottomLeftCorner<6, 3>();
		hess.bottomLeftCorner<3, 6>() = local_hess.topRightCorner<3, 6>();
		hess.bottomRightCorner<3, 3>() = local_hess.topLeftCorner<3, 3>();
		break;
	}

	case EdgeEdgeDistanceType::EA0_EB: {
		const Eigen::Matrix<T, 9, 9> local_hess = point_line_distance_hessian(ea0, eb0, eb1);
		hess.topLeftCorner<3, 3>() = local_hess.topLeftCorner<3, 3>();
		hess.topRightCorner<3, 6>() = local_hess.topRightCorner<3, 6>();
		hess.bottomLeftCorner<6, 3>() = local_hess.bottomLeftCorner<6, 3>();
		hess.bottomRightCorner<6, 6>() = local_hess.bottomRightCorner<6, 6>();
		break;
	}

	case EdgeEdgeDistanceType::EA1_EB:
		hess.bottomRightCorner<9, 9>() =
			point_line_distance_hessian(ea1, eb0, eb1);
		break;

	case EdgeEdgeDistanceType::EA_EB:
		hess = line_line_distance_hessian(ea0, ea1, eb0, eb1);
		break;

	default:
		throw std::invalid_argument(
			"Invalid distance type for edge-edge distance hessian!");
	}

	return hess;
}



int main() {

	std::random_device rd;
	std::mt19937 gen(rd());

	std::uniform_real_distribution<double> epsv_rand(0.0, 1.0);
	const double epsv = epsv_rand(gen);
	const double dt = epsv_rand(gen);

	std::uniform_real_distribution<double> v_rand(-10.0, 10.0);
	//Eigen::Vector3d v0 = Eigen::Vector3d::NullaryExpr([&]() { return v_rand(gen); });
	//Eigen::Vector3d v1 = Eigen::Vector3d::NullaryExpr([&]() { return v_rand(gen); });
	//Eigen::Vector3d v2 = Eigen::Vector3d::NullaryExpr([&]() { return v_rand(gen); });
	//Eigen::Vector3d v3 = Eigen::Vector3d::NullaryExpr([&]() { return v_rand(gen); });

	Eigen::Vector3d v0_prev = Eigen::Vector3d::NullaryExpr([&]() { return v_rand(gen); });
	Eigen::Vector3d v1_prev = Eigen::Vector3d::NullaryExpr([&]() { return v_rand(gen); });
	Eigen::Vector3d v2_prev = Eigen::Vector3d::NullaryExpr([&]() { return v_rand(gen); });
	Eigen::Vector3d v3_prev = Eigen::Vector3d::NullaryExpr([&]() { return v_rand(gen); });


	const double mu = epsv_rand(gen);

	//std::uniform_real_distribution<double> kappa_rand(1.0, 1.e6);
	const double kappa = 1.e5;// kappa_rand(gen);

	const double d_hat = 1.e-2;
	const double d_min = 1.e-12;



	Eigen::VectorXd vs_in_tmp(12);

	//vs_in << 
	//	0.7302, 0.5984, 0.1560,
	//	0.6501, 0.4262, 0.1962,
	//	0.7381, 0.5982, 0.1657,
	//	0.3487, 0.8313, 0.3531;

	//vs_in <<
	//	0.1857, 0.6724, 0.3401,
	//	0.1512, 0.2145, 0.4900,
	//	0.1852, 0.6730, 0.3397,
	//	0.5421, 0.8421, 0.1004;

	vs_in_tmp <<
		0.3314, 0.8102, 0.7395,
		0.5623, 0.5091, 0.6382,
		0.3305, 0.8106, 0.7389,
		0.2648, 0.9272, 0.8967;

	Eigen::Matrix<double, 3, 2> tangent_basis;
	Eigen::Vector2<double> lerp_alpha, bycen_coords;
	Eigen::Vector3<double> relative_velocity;
	{

		Eigen::Vector3<double> v0 = vs_in_tmp.segment(0, 3);
		Eigen::Vector3<double> v1 = vs_in_tmp.segment(3, 3);
		Eigen::Vector3<double> v2 = vs_in_tmp.segment(6, 3);
		Eigen::Vector3<double> v3 = vs_in_tmp.segment(9, 3);

		tangent_basis = compute_tangent_basis_edge_edge(v0, v1, v2, v3);
		lerp_alpha = compute_lerp_alpha_edge_edge_closest_point(v0, v1, v2, v3);
		//relative_velocity = lerp(dv0, dv1, lerp_alpha[0]) - lerp(dv2, dv3, lerp_alpha[1]);
	}


	auto calc_phi2 = [&](autodiff::VectorXvar vs_in)->autodiff::var {

		const double dt2 = dt * dt;
		const double dt2_kappa = dt2 * kappa;

		Eigen::Vector3<autodiff::var> v0 = vs_in.segment(0, 3);
		Eigen::Vector3<autodiff::var> v1 = vs_in.segment(3, 3);
		Eigen::Vector3<autodiff::var> v2 = vs_in.segment(6, 3);
		Eigen::Vector3<autodiff::var> v3 = vs_in.segment(9, 3);

		Eigen::Vector3<autodiff::var> dv0 = v0 - v0_prev;
		Eigen::Vector3<autodiff::var> dv1 = v1 - v1_prev;
		Eigen::Vector3<autodiff::var> dv2 = v2 - v2_prev;
		Eigen::Vector3<autodiff::var> dv3 = v3 - v3_prev;

		//Eigen::Matrix<autodiff::var, 3, 2> tangent_basis;
		//Eigen::Vector2<autodiff::var> lerp_alpha, bycen_coords;
		Eigen::Vector3<autodiff::var> relative_velocity;
		////if constexpr (IS_EDGE_EDGE) {
		//tangent_basis = compute_tangent_basis_edge_edge(v0, v1, v2, v3);
		//lerp_alpha = compute_lerp_alpha_edge_edge_closest_point(v0, v1, v2, v3);
		relative_velocity = lerp(dv0, dv1, lerp_alpha[0]) - lerp(dv2, dv3, lerp_alpha[1]);
		//relative_velocity =
		//	(1.0 - lerp_alpha[0]) * v0 + lerp_alpha[0] * v1 -
		//	(1.0 - lerp_alpha[1]) * v2 + lerp_alpha[1] * v3;
		//}
		//else if constexpr (IS_VERTEX_FACE) {
		//	tangent_basis = compute_tangent_basis_point_triangle(v0, v1, v2, v3);
		//	bycen_coords = compute_bycentric_point_triangle_closest_point(v0, v1, v2, v3);
		//	relative_velocity = dv0 - compute_value_at_barycentric_point(dv1, dv2, dv3, bycen_coords);
		//}
		//########################

		autodiff::var dist2 = -1.0;
		//if constexpr (IS_EDGE_EDGE) {
		dist2 = edge_edge_distance(v0, v1, v2, v3);
		//}
		//else if constexpr (IS_VERTEX_FACE) {
		//	dist2 = SEMO::point_triangle_distance(v0, v1, v2, v3);
		//}


		assert(dist2 > 0);
		autodiff::var d = sqrt(dist2);

		//--------------------------
		//double b = SEMO::barrier(dist2 - d_min * d_min, (2.0 * d_min + d_hat) * d_hat);
		autodiff::var d_modi = d - d_min;
		autodiff::var b{};
		{
			//b = -(dist2 - d_hat * d_hat) * (dist2 - d_hat * d_hat) * std::log(dist2 / d_hat / d_hat);
			b = -(d_modi - d_hat) * (d_modi - d_hat) * log(d_modi / d_hat);
		}
		//double db = SEMO::barrier_first_derivative(dist2 - d_min * d_min, (2.0 * d_min + d_hat) * d_hat);
		autodiff::var db{};
		{
			//db = (d_hat * d_hat - dist2) * (2.0 * std::log(dist2 / d_hat / d_hat) - d_hat * d_hat / dist2 + 1.0);
			db = (d_hat - d_modi) * (2.0 * log(d_modi / d_hat) - d_hat / d_modi + 1.0);
		}
		//double d2b = SEMO::barrier_second_derivative(dist2 - d_min * d_min, (2.0 * d_min + d_hat) * d_hat);
		autodiff::var d2b{};
		{
			//d2b = (d_hat * d_hat / dist2 + 2.0) * d_hat * d_hat / dist2 - 
			//	2.0 * std::log(dist2 / d_hat / d_hat) - 3.0;
			d2b = (d_hat / d_modi + 2.0) * d_hat / d_modi -
				2.0 * log(d_modi / d_hat) - 3.0;
		}

		autodiff::var d3b{};
		{
			d3b = - 2.0 * (d_hat / d_modi + 1.0) * d_hat / d_modi / d_modi -
				2.0 / d_modi;
		}


		//double b = SEMO::barrier(d - d_min, d_hat);
		//--------------------------
		//assert(std::isfinite(b));


		// mollifier edge
		autodiff::var thres;
		autodiff::var ek = 1.0;
		//if constexpr (IS_EDGE_EDGE) {
		thres = edge_edge_mollifier_threshold(v0, v1, v2, v3);
		ek = edge_edge_mollifier(v0, v1, v2, v3, thres);
		//}
		assert(ek <= 1.0);



		Eigen::Vector<autodiff::var, 12> grad2(12), e_g(12), grad_tmp(12);
		//########################
		//########################
		//if constexpr (IS_EDGE_EDGE) {
			grad2 = edge_edge_distance_gradient(v0, v1, v2, v3);
			//--------------------------
			grad2 /= (2.0 * d);
			//--------------------------
			e_g = edge_edge_mollifier_gradient(v0, v1, v2, v3, thres);
			grad_tmp = (dt2_kappa * ek * db) * grad2 + (dt2_kappa * b) * e_g;

		//std::cout << "grad " << std::endl;
		//std::cout << grad_tmp << std::endl;



		//Eigen::MatrixXd hess_tmp;
		////if constexpr (IS_EDGE_EDGE) {
		//	auto hess2 = SEMO::edge_edge_distance_hessian(v0, v1, v2, v3);
		//	//--------------------------
		//	hess2 = (hess2 - 2.0 * grad2 * grad2.transpose()) / (2.0 * d);
		//	//--------------------------
		//	auto e_H = SEMO::edge_edge_mollifier_hessian(v0, v1, v2, v3, thres);
		//	Eigen::Matrix<double, 12, 12> kappa_gradb_gradeT = ((dt2_kappa * db) * grad2) * e_g.transpose();
		//	hess_tmp =
		//		kappa_gradb_gradeT + kappa_gradb_gradeT.transpose() +
		//		(dt2_kappa * b) * e_H +
		//		(dt2_kappa * ek * d2b) * grad2 * grad2.transpose() +
		//		(dt2_kappa * ek * db) * hess2;




		//########################
		//--------------------------
		//double normal_force_magnitude = -dt2_kappa * db * 2.0 * d;
		//double db = SEMO::barrier_first_derivative(d - d_min, d_hat);
		//double d2b = SEMO::barrier_second_derivative(d - d_min, d_hat);



		Eigen::MatrixX<autodiff::var> hess_tmp;
		hess_tmp.setZero(12, 12);

		auto hess2 = edge_edge_distance_hessian(v0, v1, v2, v3);
		//--------------------------
		hess2 = (hess2 - 2.0 * grad2 * grad2.transpose()) / (2.0 * d);
		//--------------------------
		//auto e_H = edge_edge_mollifier_hessian(v0, v1, v2, v3, thres);
		Eigen::Matrix<autodiff::var, 12, 12> kappa_gradb_gradeT = ((dt2_kappa * db) * grad2) * e_g.transpose();
		hess_tmp =
			kappa_gradb_gradeT + kappa_gradb_gradeT.transpose() +
			//(dt2_kappa * b) * e_H +
			(dt2_kappa * ek * d2b) * grad2 * grad2.transpose() +
			(dt2_kappa * ek * db) * hess2;


		//std::cout << "hess " << std::endl;
		//std::cout << hess_tmp << std::endl;

		//return dt2_kappa * ek * b;

		double db_d = val(db);

		auto normal_force_magnitude = -dt2_kappa*  db;
		//--------------------------
		autodiff::var scale = mu * normal_force_magnitude;
		Eigen::Vector2<autodiff::var> u = tangent_basis.transpose() * relative_velocity;
		autodiff::var norm_u = sqrt(u.squaredNorm());
		autodiff::var f0_SF_val = f0_SF(norm_u, epsv);


		Eigen::Matrix<autodiff::var, 3, 12> relative_velocity_matrix = edge_edge_relative_velocity_matrix(3, lerp_alpha);
		Eigen::Matrix<autodiff::var, 12, 2> T_friction;
		T_friction = relative_velocity_matrix.transpose() * tangent_basis;
		autodiff::var f1_over_norm_u = f1_SF_over_x(norm_u, epsv);
		grad_tmp = T_friction * (scale * f1_over_norm_u * u);
		grad_tmp -= dt2_kappa * mu * f0_SF(norm_u, epsv) * (d2b) * grad2;

		//std::cout << T_friction * u / norm_u << std::endl;

		std::cout << "numeric grad" << std::endl;
		std::cout << grad_tmp << std::endl;



		hess_tmp.setZero(12, 12);

		if (norm_u >= epsv) 
		{
			if (scale <= 0) {
				//hess_tmp.setZero(12, 12); // -PSD = NSD ⟹ 0
			}
			else {
				const Eigen::Vector2<autodiff::var> u_perp(-u[1], u[0]);
				hess_tmp += // grouped to reduce number of operations
					(T_friction * ((scale * f1_over_norm_u / (norm_u * norm_u)) * u_perp)) *
					(u_perp.transpose() * T_friction.transpose());
			}
		}
		else if (norm_u < 1.e-12) {
			if (scale <= 0) {
				//hess_tmp.setZero(12, 12); // -PSD = NSD ⟹ 0
			}
			else {
				hess_tmp += (scale * f1_over_norm_u) * T_friction * T_friction.transpose();
			}
		}
		else {
			autodiff::var f2 = df1_x_minus_f1_over_x3(norm_u, epsv);

			Eigen::Matrix<autodiff::var, 2, 2> inner_hess = f2 * u * u.transpose();
			inner_hess.diagonal().array() += f1_over_norm_u;
			inner_hess *= scale; // NOTE: negative scaling will be projected out
			//if (use_psd_hessian) inner_hess = project_to_psd(inner_hess, PSDProjectionMethod::ABS);

			hess_tmp += T_friction * inner_hess * T_friction.transpose();
		}


		hess_tmp -= (mu * dt2_kappa * d2b * f1_over_norm_u) * (
			(T_friction * u) * grad2.transpose() + grad2 * (T_friction * u).transpose());
		hess_tmp -= dt2_kappa * mu * f0_SF(norm_u, epsv) * 
			((d3b)* grad2 * grad2.transpose() + (d2b)*hess2);
		
		//dt2_kappa * mu * f0_SF(norm_u, epsv) * (d2b)*grad2;

		std::cout << "numeric hess" << std::endl;
		std::cout << hess_tmp << std::endl;


		return scale* f0_SF(norm_u, epsv);
		//return norm_u;// scale* f0_SF(norm_u, epsv);

		//########################



		//if constexpr (GRAD == true)
		//{
		//	Vector12d grad2, e_g, grad_tmp;
		//	//########################
		//	double f1_over_norm_u;
		//	Eigen::Matrix<double, 12, 2> T_friction;
		//	//########################
		//	if constexpr (IS_EDGE_EDGE) {
		//		grad2 = SEMO::edge_edge_distance_gradient(v0, v1, v2, v3);
		//		//--------------------------
		//		grad2 /= (2.0 * d);
		//		//--------------------------
		//		e_g = SEMO::edge_edge_mollifier_gradient(v0, v1, v2, v3, thres);
		//		grad_tmp = (dt2_kappa * ek * db) * grad2 + (dt2_kappa * b) * e_g;
		//		//########################
		//		if (is_act_fric) {
		//			Eigen::Matrix<double, 3, 12> relative_velocity_matrix = edge_edge_relative_velocity_matrix(3, lerp_alpha);
		//			T_friction = relative_velocity_matrix.transpose() * tangent_basis;
		//			f1_over_norm_u = f1_SF_over_x(norm_u, epsv);
		//			grad_tmp += T_friction * (scale * f1_over_norm_u * u);
		//		}
		//		//########################
		//		if constexpr (RIGID0 == true && RIGID1 == true) {
		//			Eigen::VectorXd tmp0 =
		//				m_jac_V.middleCols(idx_vs[0] * 3, 3) * grad_tmp.segment(0, 3) +
		//				m_jac_V.middleCols(idx_vs[1] * 3, 3) * grad_tmp.segment(3, 3);
		//			Eigen::VectorXd tmp1 =
		//				m_jac_V.middleCols(idx_vs[2] * 3, 3) * grad_tmp.segment(6, 3) +
		//				m_jac_V.middleCols(idx_vs[3] * 3, 3) * grad_tmp.segment(9, 3);

		//			for (int k = 0; k < 6; ++k) {
		//				m_grad_inform_tri.emplace_back(idx_rbs[0], idx_vs[0], k, tmp0(k));
		//				m_grad_inform_tri.emplace_back(idx_rbs[2], idx_vs[2], k, tmp1(k));
		//			}
		//		}
		//		if constexpr (RIGID0 == true && RIGID1 == false) {
		//			Eigen::VectorXd tmp0 =
		//				m_jac_V.middleCols(idx_vs[0] * 3, 3) * grad_tmp.segment(0, 3) +
		//				m_jac_V.middleCols(idx_vs[1] * 3, 3) * grad_tmp.segment(3, 3);
		//			for (int k = 0; k < 6; ++k) {
		//				m_grad_inform_tri.emplace_back(idx_rbs[0], idx_vs[0], k, tmp0(k));
		//			}
		//			for (int k = 0; k < 3; ++k) {
		//				m_grad_inform_tri.emplace_back(idx_rbs[2], idx_vs[2], k, grad_tmp(6 + k));
		//				m_grad_inform_tri.emplace_back(idx_rbs[3], idx_vs[3], k, grad_tmp(9 + k));
		//			}

		//		}
		//		if constexpr (RIGID0 == false && RIGID1 == true) {
		//			for (int k = 0; k < 3; ++k) {
		//				m_grad_inform_tri.emplace_back(idx_rbs[0], idx_vs[0], k, grad_tmp(0 + k));
		//				m_grad_inform_tri.emplace_back(idx_rbs[1], idx_vs[1], k, grad_tmp(3 + k));
		//			}
		//			Eigen::VectorXd tmp1 =
		//				m_jac_V.middleCols(idx_vs[2] * 3, 3) * grad_tmp.segment(6, 3) +
		//				m_jac_V.middleCols(idx_vs[3] * 3, 3) * grad_tmp.segment(9, 3);
		//			for (int k = 0; k < 6; ++k) {
		//				m_grad_inform_tri.emplace_back(idx_rbs[2], idx_vs[2], k, tmp1(k));
		//			}

		//		}
		//		if constexpr (RIGID0 == false && RIGID1 == false) {
		//			for (int k = 0; k < 3; ++k) {
		//				for (int l = 0; l < 4; ++l) {
		//					m_grad_inform_tri.emplace_back(idx_rbs[l], idx_vs[l], k, grad_tmp(3 * l + k));
		//				}
		//			}
		//		}
		//	}
		//	else if constexpr (IS_VERTEX_FACE) {
		//		grad2 = SEMO::point_triangle_distance_gradient(v0, v1, v2, v3);
		//		//--------------------------
		//		grad2 /= (2.0 * d);
		//		//--------------------------
		//		grad_tmp = dt2_kappa * db * grad2;
		//		//########################
		//		if (is_act_fric) {
		//			Eigen::Matrix<double, 3, 12> relative_velocity_matrix =
		//				point_triangle_relative_velocity_matrix(3, bycen_coords);
		//			T_friction = relative_velocity_matrix.transpose() * tangent_basis;
		//			f1_over_norm_u = f1_SF_over_x(norm_u, epsv);
		//			grad_tmp += T_friction * (scale * f1_over_norm_u * u);
		//		}
		//		//########################
		//		if constexpr (RIGID0 == true && RIGID1 == true) {
		//			Eigen::VectorXd tmp0 =
		//				m_jac_V.middleCols(idx_vs[0] * 3, 3) * grad_tmp.segment(0, 3);
		//			Eigen::VectorXd tmp1 =
		//				m_jac_V.middleCols(idx_vs[1] * 3, 3) * grad_tmp.segment(3, 3) +
		//				m_jac_V.middleCols(idx_vs[2] * 3, 3) * grad_tmp.segment(6, 3) +
		//				m_jac_V.middleCols(idx_vs[3] * 3, 3) * grad_tmp.segment(9, 3);

		//			for (int k = 0; k < 6; ++k) {
		//				m_grad_inform_tri.emplace_back(idx_rbs[0], idx_vs[0], k, tmp0(k));
		//				m_grad_inform_tri.emplace_back(idx_rbs[1], idx_vs[1], k, tmp1(k));
		//			}
		//		}
		//		if constexpr (RIGID0 == true && RIGID1 == false) {
		//			Eigen::VectorXd tmp0 =
		//				m_jac_V.middleCols(idx_vs[0] * 3, 3) * grad_tmp.segment(0, 3);
		//			for (int k = 0; k < 6; ++k) {
		//				m_grad_inform_tri.emplace_back(idx_rbs[0], idx_vs[0], k, tmp0(k));
		//			}
		//			for (int k = 0; k < 3; ++k) {
		//				m_grad_inform_tri.emplace_back(idx_rbs[1], idx_vs[1], k, grad_tmp(3 + k));
		//				m_grad_inform_tri.emplace_back(idx_rbs[2], idx_vs[2], k, grad_tmp(6 + k));
		//				m_grad_inform_tri.emplace_back(idx_rbs[3], idx_vs[3], k, grad_tmp(9 + k));
		//			}
		//		}
		//		if constexpr (RIGID0 == false && RIGID1 == true) {
		//			for (int k = 0; k < 3; ++k) {
		//				m_grad_inform_tri.emplace_back(idx_rbs[0], idx_vs[0], k, grad_tmp(0 + k));
		//			}
		//			Eigen::VectorXd tmp1 =
		//				m_jac_V.middleCols(idx_vs[1] * 3, 3) * grad_tmp.segment(3, 3) +
		//				m_jac_V.middleCols(idx_vs[2] * 3, 3) * grad_tmp.segment(6, 3) +
		//				m_jac_V.middleCols(idx_vs[3] * 3, 3) * grad_tmp.segment(9, 3);
		//			for (int k = 0; k < 6; ++k) {
		//				m_grad_inform_tri.emplace_back(idx_rbs[1], idx_vs[1], k, tmp1(k));
		//			}
		//		}
		//		if constexpr (RIGID0 == false && RIGID1 == false) {
		//			for (int l = 0; l < 4; ++l) {
		//				for (int k = 0; k < 3; ++k) {
		//					m_grad_inform_tri.emplace_back(idx_rbs[l], idx_vs[l], k, grad_tmp(3 * l + k));
		//				}
		//			}

		//		}
		//	}




		//	if constexpr (HESS == true)
		//	{
		//		Eigen::MatrixXd hess_tmp;
		//		if constexpr (IS_EDGE_EDGE) {
		//			auto hess2 = SEMO::edge_edge_distance_hessian(v0, v1, v2, v3);
		//			//--------------------------
		//			hess2 = (hess2 - 2.0 * grad2 * grad2.transpose()) / (2.0 * d);
		//			//--------------------------
		//			auto e_H = SEMO::edge_edge_mollifier_hessian(v0, v1, v2, v3, thres);
		//			Eigen::Matrix<double, 12, 12> kappa_gradb_gradeT = ((dt2_kappa * db) * grad2) * e_g.transpose();
		//			hess_tmp =
		//				kappa_gradb_gradeT + kappa_gradb_gradeT.transpose() +
		//				(dt2_kappa * b) * e_H +
		//				(dt2_kappa * ek * d2b) * grad2 * grad2.transpose() +
		//				(dt2_kappa * ek * db) * hess2;
		//		}
		//		else if constexpr (IS_VERTEX_FACE) {
		//			auto hess2 = SEMO::point_triangle_distance_hessian(v0, v1, v2, v3);
		//			//--------------------------
		//			hess2 = (hess2 - 2.0 * grad2 * grad2.transpose()) / (2.0 * d);
		//			//--------------------------
		//			hess_tmp =
		//				(dt2_kappa * d2b) * grad2 * grad2.transpose() +
		//				(dt2_kappa * db) * hess2;
		//		}


		//		//########################
		//		if (is_act_fric) {

		//			if (norm_u >= epsv) {
		//				if (scale <= 0) {
		//					//hess_tmp.setZero(12, 12); // -PSD = NSD ⟹ 0
		//				}
		//				else {
		//					const Eigen::Vector2d u_perp(-u[1], u[0]);
		//					hess_tmp += // grouped to reduce number of operations
		//						(T_friction * ((scale * f1_over_norm_u / (norm_u * norm_u)) * u_perp)) *
		//						(u_perp.transpose() * T_friction.transpose());
		//				}
		//			}
		//			else if (norm_u == 0) {
		//				if (scale <= 0) {
		//					//hess_tmp.setZero(12, 12); // -PSD = NSD ⟹ 0
		//				}
		//				else {
		//					hess_tmp += (scale * f1_over_norm_u) * T_friction * T_friction.transpose();
		//				}
		//			}
		//			else {
		//				double f2 = df1_x_minus_f1_over_x3(norm_u, epsv);

		//				MatrixMax2d inner_hess = f2 * u * u.transpose();
		//				inner_hess.diagonal().array() += f1_over_norm_u;
		//				inner_hess *= scale; // NOTE: negative scaling will be projected out
		//				//if (use_psd_hessian) inner_hess = project_to_psd(inner_hess, PSDProjectionMethod::ABS);

		//				hess_tmp += T_friction * inner_hess * T_friction.transpose();
		//			}
		//		}
		//		//########################


		//		Eigen::MatrixXd hess;
		//		if constexpr (IS_EDGE_EDGE) {
		//			if constexpr (RIGID0 == true && RIGID1 == true) {
		//				Eigen::MatrixXd jac_Vi = Eigen::MatrixXd::Zero(12, 12);
		//				jac_Vi.block(0, 0, 3, 6) = m_jac_V.middleCols(idx_vs[0] * 3, 3).transpose();
		//				jac_Vi.block(3, 0, 3, 6) = m_jac_V.middleCols(idx_vs[1] * 3, 3).transpose();
		//				jac_Vi.block(6, 6, 3, 6) = m_jac_V.middleCols(idx_vs[2] * 3, 3).transpose();
		//				jac_Vi.block(9, 6, 3, 6) = m_jac_V.middleCols(idx_vs[3] * 3, 3).transpose();
		//				hess = jac_Vi.transpose() * hess_tmp * jac_Vi;

		//				for (int j = 0; j < 3; j++) {
		//					hess.block(0, 0, 6, 6) +=
		//						m_hess_V.middleRows(6 * (idx_vs[0] * 3 + j), 6) * grad_tmp[0 * 3 + j] +
		//						m_hess_V.middleRows(6 * (idx_vs[1] * 3 + j), 6) * grad_tmp[1 * 3 + j];
		//					hess.block(6, 6, 6, 6) +=
		//						m_hess_V.middleRows(6 * (idx_vs[2] * 3 + j), 6) * grad_tmp[2 * 3 + j] +
		//						m_hess_V.middleRows(6 * (idx_vs[3] * 3 + j), 6) * grad_tmp[3 * 3 + j];
		//				}
		//			}
		//			if constexpr (RIGID0 == true && RIGID1 == false) {
		//				Eigen::MatrixXd jac_Vi = Eigen::MatrixXd::Zero(12, 12);
		//				jac_Vi.block(0, 0, 3, 6) = m_jac_V.middleCols(idx_vs[0] * 3, 3).transpose();
		//				jac_Vi.block(3, 0, 3, 6) = m_jac_V.middleCols(idx_vs[1] * 3, 3).transpose();
		//				jac_Vi.block(6, 6, 6, 6).setIdentity();
		//				hess = jac_Vi.transpose() * hess_tmp * jac_Vi;

		//				for (int j = 0; j < 3; j++) {
		//					hess.block(0, 0, 6, 6) +=
		//						m_hess_V.middleRows(6 * (idx_vs[0] * 3 + j), 6) * grad_tmp[0 * 3 + j] +
		//						m_hess_V.middleRows(6 * (idx_vs[1] * 3 + j), 6) * grad_tmp[1 * 3 + j];
		//				}

		//			}
		//			if constexpr (RIGID0 == false && RIGID1 == true) {
		//				Eigen::MatrixXd jac_Vi = MatrixMax12d::Zero(12, 12);
		//				jac_Vi.block(0, 0, 6, 6).setIdentity();
		//				jac_Vi.block(6, 6, 3, 6) = m_jac_V.middleCols(idx_vs[2] * 3, 3).transpose();
		//				jac_Vi.block(9, 6, 3, 6) = m_jac_V.middleCols(idx_vs[3] * 3, 3).transpose();
		//				hess = jac_Vi.transpose() * hess_tmp * jac_Vi;

		//				for (int j = 0; j < 3; j++) {
		//					hess.block(6, 6, 6, 6) +=
		//						m_hess_V.middleRows(6 * (idx_vs[2] * 3 + j), 6) * grad_tmp[2 * 3 + j] +
		//						m_hess_V.middleRows(6 * (idx_vs[3] * 3 + j), 6) * grad_tmp[3 * 3 + j];
		//				}

		//			}
		//			if constexpr (RIGID0 == false && RIGID1 == false) {
		//				std::swap(hess, hess_tmp);
		//			}

		//		}
		//		else if constexpr (IS_VERTEX_FACE) {
		//			if constexpr (RIGID0 == true && RIGID1 == true) {
		//				Eigen::MatrixXd jac_Vi = Eigen::MatrixXd::Zero(12, 12);
		//				jac_Vi.block(0, 0, 3, 6) = m_jac_V.middleCols(idx_vs[0] * 3, 3).transpose();
		//				jac_Vi.block(3, 6, 3, 6) = m_jac_V.middleCols(idx_vs[1] * 3, 3).transpose();
		//				jac_Vi.block(6, 6, 3, 6) = m_jac_V.middleCols(idx_vs[2] * 3, 3).transpose();
		//				jac_Vi.block(9, 6, 3, 6) = m_jac_V.middleCols(idx_vs[3] * 3, 3).transpose();
		//				hess = jac_Vi.transpose() * hess_tmp * jac_Vi;

		//				for (int j = 0; j < 3; j++) {
		//					hess.block(0, 0, 6, 6) +=
		//						m_hess_V.middleRows(6 * (idx_vs[0] * 3 + j), 6) * grad_tmp[0 + j];
		//					hess.block(6, 6, 6, 6) +=
		//						m_hess_V.middleRows(6 * (idx_vs[1] * 3 + j), 6) * grad_tmp[3 + j] +
		//						m_hess_V.middleRows(6 * (idx_vs[2] * 3 + j), 6) * grad_tmp[6 + j] +
		//						m_hess_V.middleRows(6 * (idx_vs[3] * 3 + j), 6) * grad_tmp[9 + j];
		//				}
		//			}
		//			if constexpr (RIGID0 == true && RIGID1 == false) {
		//				Eigen::MatrixXd jac_Vi = Eigen::MatrixXd::Zero(12, 15);
		//				jac_Vi.block(0, 0, 3, 6) = m_jac_V.middleCols(idx_vs[0] * 3, 3).transpose();
		//				jac_Vi.block(3, 6, 9, 9).setIdentity();
		//				hess = jac_Vi.transpose() * hess_tmp * jac_Vi;

		//				for (int j = 0; j < 3; j++) {
		//					hess.block(0, 0, 6, 6) +=
		//						m_hess_V.middleRows(6 * (idx_vs[0] * 3 + j), 6) * grad_tmp[0 + j];
		//				}
		//			}
		//			if constexpr (RIGID0 == false && RIGID1 == true) {
		//				Eigen::MatrixXd jac_Vi = Eigen::MatrixXd::Zero(12, 9);
		//				jac_Vi.block(0, 0, 3, 3).setIdentity();
		//				jac_Vi.block(3, 3, 3, 6) = m_jac_V.middleCols(idx_vs[1] * 3, 3).transpose();
		//				jac_Vi.block(6, 3, 3, 6) = m_jac_V.middleCols(idx_vs[2] * 3, 3).transpose();
		//				jac_Vi.block(9, 3, 3, 6) = m_jac_V.middleCols(idx_vs[3] * 3, 3).transpose();
		//				hess = jac_Vi.transpose() * hess_tmp * jac_Vi;

		//				for (int j = 0; j < 3; j++) {
		//					hess.block(3, 3, 6, 6) +=
		//						m_hess_V.middleRows(6 * (idx_vs[1] * 3 + j), 6) * grad_tmp[3 + j] +
		//						m_hess_V.middleRows(6 * (idx_vs[2] * 3 + j), 6) * grad_tmp[6 + j] +
		//						m_hess_V.middleRows(6 * (idx_vs[3] * 3 + j), 6) * grad_tmp[9 + j];
		//				}

		//			}
		//			if constexpr (RIGID0 == false && RIGID1 == false) {
		//				std::swap(hess, hess_tmp);
		//			}

		//		}



		//		if (use_psd_hessian) hess = project_to_psd(hess, PSDProjectionMethod::ABS);



		//		if constexpr (RIGID0 == true && RIGID1 == true) {
		//			for (int dof_i = 0; dof_i < 6; dof_i++) {
		//				for (int dof_j = 0; dof_j < 6; dof_j++) {
		//					m_hess_inform_tri.emplace_back(
		//						idx_rbs[0], idx_vs[0], dof_i, idx_rbs[0], idx_vs[0], dof_j, hess(6 * 0 + dof_i, 6 * 0 + dof_j));
		//					m_hess_inform_tri.emplace_back(
		//						idx_rbs[0], idx_vs[0], dof_i, idx_rbs[2], idx_vs[2], dof_j, hess(6 * 0 + dof_i, 6 * 1 + dof_j));
		//					m_hess_inform_tri.emplace_back(
		//						idx_rbs[2], idx_vs[2], dof_i, idx_rbs[0], idx_vs[0], dof_j, hess(6 * 1 + dof_i, 6 * 0 + dof_j));
		//					m_hess_inform_tri.emplace_back(
		//						idx_rbs[2], idx_vs[2], dof_i, idx_rbs[2], idx_vs[2], dof_j, hess(6 * 1 + dof_i, 6 * 1 + dof_j));

		//				}
		//			}
		//		}
		//		if constexpr (RIGID0 == true && RIGID1 == false) {
		//			if constexpr (IS_EDGE_EDGE) {


		//				for (int dof_i = 0; dof_i < 6; dof_i++) {
		//					for (int dof_j = 0; dof_j < 6; dof_j++) {
		//						m_hess_inform_tri.emplace_back(
		//							idx_rbs[0], idx_vs[0], dof_i, idx_rbs[0], idx_vs[0], dof_j, hess(0 + dof_i, 0 + dof_j));

		//					}
		//					for (int dof_j = 0; dof_j < 3; dof_j++) {
		//						m_hess_inform_tri.emplace_back(
		//							idx_rbs[0], idx_vs[0], dof_i, idx_rbs[2], idx_vs[2], dof_j, hess(0 + dof_i, 6 + dof_j));
		//						m_hess_inform_tri.emplace_back(
		//							idx_rbs[0], idx_vs[0], dof_i, idx_rbs[3], idx_vs[3], dof_j, hess(0 + dof_i, 9 + dof_j));
		//					}
		//				}
		//				for (int dof_i = 0; dof_i < 3; dof_i++) {
		//					for (int dof_j = 0; dof_j < 6; dof_j++) {
		//						m_hess_inform_tri.emplace_back(
		//							idx_rbs[2], idx_vs[2], dof_i, idx_rbs[0], idx_vs[0], dof_j, hess(6 + dof_i, 0 + dof_j));
		//						m_hess_inform_tri.emplace_back(
		//							idx_rbs[3], idx_vs[3], dof_i, idx_rbs[0], idx_vs[0], dof_j, hess(9 + dof_i, 0 + dof_j));

		//					}
		//					for (int dof_j = 0; dof_j < 3; dof_j++) {
		//						m_hess_inform_tri.emplace_back(
		//							idx_rbs[2], idx_vs[2], dof_i, idx_rbs[2], idx_vs[2], dof_j, hess(6 + dof_i, 6 + dof_j));
		//						m_hess_inform_tri.emplace_back(
		//							idx_rbs[2], idx_vs[2], dof_i, idx_rbs[3], idx_vs[3], dof_j, hess(6 + dof_i, 9 + dof_j));
		//						m_hess_inform_tri.emplace_back(
		//							idx_rbs[3], idx_vs[3], dof_i, idx_rbs[2], idx_vs[2], dof_j, hess(9 + dof_i, 6 + dof_j));
		//						m_hess_inform_tri.emplace_back(
		//							idx_rbs[3], idx_vs[3], dof_i, idx_rbs[3], idx_vs[3], dof_j, hess(9 + dof_i, 9 + dof_j));

		//					}
		//				}
		//			}
		//			else if constexpr (IS_VERTEX_FACE) {

		//				for (int dof_i = 0; dof_i < 6; dof_i++) {
		//					for (int dof_j = 0; dof_j < 6; dof_j++) {
		//						m_hess_inform_tri.emplace_back(
		//							idx_rbs[0], idx_vs[0], dof_i,
		//							idx_rbs[0], idx_vs[0], dof_j,
		//							hess(0 + dof_i, 0 + dof_j));
		//					}
		//					for (int dof_j = 0; dof_j < 3; dof_j++) {
		//						for (int l = 1; l < 4; ++l) {
		//							m_hess_inform_tri.emplace_back(
		//								idx_rbs[0], idx_vs[0], dof_i,
		//								idx_rbs[l], idx_vs[l], dof_j,
		//								hess(0 + dof_i, 3 + 3 * l + dof_j));
		//						}
		//					}
		//				}
		//				for (int dof_i = 0; dof_i < 3; dof_i++) {
		//					for (int dof_j = 0; dof_j < 6; dof_j++) {
		//						for (int k = 1; k < 4; ++k) {
		//							m_hess_inform_tri.emplace_back(
		//								idx_rbs[k], idx_vs[k], dof_i,
		//								idx_rbs[0], idx_vs[0], dof_j,
		//								hess(3 + 3 * k + dof_i, 0 + dof_j));
		//						}
		//					}
		//					for (int dof_j = 0; dof_j < 3; dof_j++) {
		//						for (int k = 1; k < 4; ++k) {
		//							for (int l = 1; l < 4; ++l) {
		//								m_hess_inform_tri.emplace_back(
		//									idx_rbs[k], idx_vs[k], dof_i,
		//									idx_rbs[l], idx_vs[l], dof_j,
		//									hess(3 + 3 * k + dof_i, 3 + 3 * l + dof_j));
		//							}
		//						}
		//					}
		//				}
		//			}
		//		}
		//		if constexpr (RIGID0 == false && RIGID1 == true) {
		//			if constexpr (IS_EDGE_EDGE) {


		//				for (int dof_i = 0; dof_i < 6; dof_i++) {
		//					for (int dof_j = 0; dof_j < 6; dof_j++) {
		//						m_hess_inform_tri.emplace_back(
		//							idx_rbs[2], idx_vs[2], dof_i, idx_rbs[2], idx_vs[2], dof_j, hess(6 + dof_i, 6 + dof_j));
		//					}
		//					for (int dof_j = 0; dof_j < 3; dof_j++) {
		//						m_hess_inform_tri.emplace_back(
		//							idx_rbs[2], idx_vs[2], dof_i, idx_rbs[0], idx_vs[0], dof_j, hess(6 + dof_i, 0 + dof_j));
		//						m_hess_inform_tri.emplace_back(
		//							idx_rbs[2], idx_vs[2], dof_i, idx_rbs[1], idx_vs[1], dof_j, hess(6 + dof_i, 3 + dof_j));

		//					}
		//				}
		//				for (int dof_i = 0; dof_i < 3; dof_i++) {
		//					for (int dof_j = 0; dof_j < 6; dof_j++) {
		//						m_hess_inform_tri.emplace_back(
		//							idx_rbs[0], idx_vs[0], dof_i, idx_rbs[2], idx_vs[2], dof_j, hess(0 + dof_i, 6 + dof_j));
		//						m_hess_inform_tri.emplace_back(
		//							idx_rbs[1], idx_vs[1], dof_i, idx_rbs[2], idx_vs[2], dof_j, hess(3 + dof_i, 6 + dof_j));
		//					}
		//					for (int dof_j = 0; dof_j < 3; dof_j++) {
		//						m_hess_inform_tri.emplace_back(
		//							idx_rbs[0], idx_vs[0], dof_i, idx_rbs[0], idx_vs[0], dof_j, hess(0 + dof_i, 0 + dof_j));
		//						m_hess_inform_tri.emplace_back(
		//							idx_rbs[0], idx_vs[0], dof_i, idx_rbs[1], idx_vs[1], dof_j, hess(0 + dof_i, 3 + dof_j));
		//						m_hess_inform_tri.emplace_back(
		//							idx_rbs[1], idx_vs[1], dof_i, idx_rbs[0], idx_vs[0], dof_j, hess(3 + dof_i, 0 + dof_j));
		//						m_hess_inform_tri.emplace_back(
		//							idx_rbs[1], idx_vs[1], dof_i, idx_rbs[1], idx_vs[1], dof_j, hess(3 + dof_i, 3 + dof_j));

		//					}
		//				}
		//			}
		//			else if constexpr (IS_VERTEX_FACE) {


		//				for (int dof_i = 0; dof_i < 6; dof_i++) {
		//					for (int dof_j = 0; dof_j < 6; dof_j++) {
		//						m_hess_inform_tri.emplace_back(
		//							idx_rbs[2], idx_vs[2], dof_i, idx_rbs[2], idx_vs[2], dof_j, hess(3 + dof_i, 3 + dof_j));

		//					}
		//					for (int dof_j = 0; dof_j < 3; dof_j++) {
		//						m_hess_inform_tri.emplace_back(
		//							idx_rbs[2], idx_vs[2], dof_i, idx_rbs[0], idx_vs[0], dof_j, hess(3 + dof_i, 0 + dof_j));

		//					}
		//				}
		//				for (int dof_i = 0; dof_i < 3; dof_i++) {
		//					for (int dof_j = 0; dof_j < 6; dof_j++) {
		//						m_hess_inform_tri.emplace_back(
		//							idx_rbs[0], idx_vs[0], dof_i, idx_rbs[2], idx_vs[2], dof_j, hess(0 + dof_i, 3 + dof_j));

		//					}
		//					for (int dof_j = 0; dof_j < 3; dof_j++) {
		//						m_hess_inform_tri.emplace_back(
		//							idx_rbs[0], idx_vs[0], dof_i, idx_rbs[0], idx_vs[0], dof_j, hess(0 + dof_i, 0 + dof_j));

		//					}
		//				}
		//			}

		//		}
		//		if constexpr (RIGID0 == false && RIGID1 == false) {

		//			for (int dof_i = 0; dof_i < 3; ++dof_i) {
		//				for (int dof_j = 0; dof_j < 3; ++dof_j) {

		//					for (int k = 0; k < 4; ++k) {
		//						for (int l = 0; l < 4; ++l) {
		//							m_hess_inform_tri.emplace_back(
		//								idx_rbs[k], idx_vs[k], dof_i,
		//								idx_rbs[l], idx_vs[l], dof_j,
		//								hess(3 * k + dof_i, 3 * l + dof_j));
		//						}
		//					}

		//				}
		//			}
		//		}

		//	} // 헤스



		};




	autodiff::VectorXvar vs_in(12);

	vs_in = vs_in_tmp;


	autodiff::var u = calc_phi2(vs_in);
	Eigen::VectorXd grad;
	auto hess = autodiff::hessian(u, vs_in, grad);

	std::cout << "val : " << u << std::endl;
	std::cout << grad << std::endl;
	std::cout << hess << std::endl;


}